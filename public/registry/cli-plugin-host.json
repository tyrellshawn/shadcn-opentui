{
  "name": "cli-plugin-host",
  "type": "registry:lib",
  "title": "CLI Plugin Host",
  "description": "Host for managing CLI app execution, lifecycle, and adapters.",
  "dependencies": [
    "ink@^6.6.0"
  ],
  "registryDependencies": [
    "cli-plugin-types",
    "cli-app-registry",
    "cli-terminal-bridge",
    "cli-ink-adapter"
  ],
  "files": [
    {
      "path": "lib/opentui/plugins/cli/cli-plugin-host.ts",
      "content": "// CLI Plugin Host\n// Manages CLI app execution and lifecycle\n\nimport type {\n  CLIPluginHost,\n  CLIPluginHostOptions,\n  CLIAppDefinition,\n  CLIAppInstance,\n  CLIAppStatus,\n  CLIAppContext,\n  CLISignal,\n  CLILibrary,\n  ICLIAdapter,\n  CLIRenderInstance,\n} from \"./types\"\nimport type { OpenTUIRuntimeContext } from \"../../types\"\nimport { createCLIAppRegistry, createCLIAdapterRegistry } from \"./cli-app-registry\"\nimport { createExtendedCLITerminalBridge, type ExtendedCLITerminalBridge } from \"./cli-terminal-bridge\"\nimport { createInkAdapter } from \"./adapters/ink-adapter\"\n\n/**\n * Generate a unique ID\n */\nfunction generateId(): string {\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n}\n\n/**\n * Generate a pseudo process ID\n */\nlet pidCounter = 1000\nfunction generatePid(): number {\n  return pidCounter++\n}\n\n/**\n * CLI App Instance Implementation\n */\nclass CLIAppInstanceImpl implements CLIAppInstance {\n  readonly id: string\n  readonly app: CLIAppDefinition\n  readonly startTime: Date\n  readonly pid: number\n  \n  status: CLIAppStatus = \"starting\"\n  exitCode?: number\n  error?: Error\n\n  private renderInstance: CLIRenderInstance | null = null\n  private bridge: ExtendedCLITerminalBridge | null = null\n  private statusListeners = new Set<(status: CLIAppStatus) => void>()\n  private exitListeners = new Set<(code: number) => void>()\n  private errorListeners = new Set<(error: Error) => void>()\n  private outputListeners = new Set<(output: string) => void>()\n\n  constructor(\n    id: string,\n    app: CLIAppDefinition,\n    renderInstance: CLIRenderInstance,\n    bridge: ExtendedCLITerminalBridge\n  ) {\n    this.id = id\n    this.app = app\n    this.startTime = new Date()\n    this.pid = generatePid()\n    this.renderInstance = renderInstance\n    this.bridge = bridge\n    this.status = \"running\"\n  }\n\n  private setStatus(status: CLIAppStatus): void {\n    this.status = status\n    this.statusListeners.forEach((listener) => listener(status))\n  }\n\n  suspend(): void {\n    if (this.status !== \"running\") return\n    this.setStatus(\"suspended\")\n    this.renderInstance?.pause()\n    this.app.lifecycle?.onSuspend?.()\n  }\n\n  resume(): void {\n    if (this.status !== \"suspended\") return\n    this.setStatus(\"running\")\n    this.renderInstance?.resume()\n    this.app.lifecycle?.onResume?.()\n  }\n\n  terminate(code: number = 0): void {\n    if (this.status === \"terminated\" || this.status === \"exiting\") return\n    \n    this.setStatus(\"exiting\")\n    this.exitCode = code\n    \n    try {\n      this.renderInstance?.unmount()\n    } catch (err) {\n      // Ignore unmount errors\n    }\n    \n    this.setStatus(\"terminated\")\n    this.app.lifecycle?.onExit?.(code)\n    this.exitListeners.forEach((listener) => listener(code))\n  }\n\n  sendInput(input: string): void {\n    if (this.status !== \"running\" || !this.bridge) return\n    this.bridge.dispatchKeyPress(input, { ctrl: false, alt: false, shift: false, meta: false })\n  }\n\n  sendSignal(signal: CLISignal): void {\n    switch (signal) {\n      case \"SIGINT\":\n      case \"SIGTERM\":\n        this.terminate(130) // Standard exit code for SIGINT\n        break\n      case \"SIGKILL\":\n        this.terminate(137) // Standard exit code for SIGKILL\n        break\n      case \"SIGHUP\":\n        this.terminate(129) // Standard exit code for SIGHUP\n        break\n      default:\n        // Custom signals - notify but don't terminate\n        break\n    }\n  }\n\n  onStatusChange(callback: (status: CLIAppStatus) => void): () => void {\n    this.statusListeners.add(callback)\n    return () => this.statusListeners.delete(callback)\n  }\n\n  onExit(callback: (code: number) => void): () => void {\n    this.exitListeners.add(callback)\n    return () => this.exitListeners.delete(callback)\n  }\n\n  onError(callback: (error: Error) => void): () => void {\n    this.errorListeners.add(callback)\n    return () => this.errorListeners.delete(callback)\n  }\n\n  onOutput(callback: (output: string) => void): () => void {\n    this.outputListeners.add(callback)\n    return () => this.outputListeners.delete(callback)\n  }\n\n  /**\n   * Set error and notify listeners\n   */\n  setError(error: Error): void {\n    this.error = error\n    this.setStatus(\"error\")\n    this.app.lifecycle?.onError?.(error)\n    this.errorListeners.forEach((listener) => listener(error))\n  }\n\n  /**\n   * Emit output\n   */\n  emitOutput(output: string): void {\n    this.outputListeners.forEach((listener) => listener(output))\n  }\n}\n\n/**\n * CLI Plugin Host Implementation\n */\nclass CLIPluginHostImpl implements CLIPluginHost {\n  private options: Required<CLIPluginHostOptions>\n  private appRegistry = createCLIAppRegistry()\n  private adapterRegistry = createCLIAdapterRegistry()\n  private runningInstances = new Map<string, CLIAppInstanceImpl>()\n  private foregroundInstanceId: string | null = null\n  private runtimeContext: OpenTUIRuntimeContext | null = null\n  private _initialized = false\n\n  // Event listeners\n  private launchListeners = new Set<(instance: CLIAppInstance) => void>()\n  private terminateListeners = new Set<(instance: CLIAppInstance, code: number) => void>()\n  private errorListeners = new Set<(instance: CLIAppInstance, error: Error) => void>()\n\n  constructor(options: CLIPluginHostOptions = {}) {\n    this.options = {\n      maxConcurrentApps: options.maxConcurrentApps ?? 10,\n      sandboxMode: options.sandboxMode ?? false,\n      defaultLibrary: options.defaultLibrary ?? \"ink\",\n      defaultLibraryVersion: options.defaultLibraryVersion ?? \">=6.6.0\",\n      adapters: options.adapters ?? [],\n      autoInitialize: options.autoInitialize ?? false,\n    }\n  }\n\n  // ============================================\n  // App Management\n  // ============================================\n\n  registerApp(app: CLIAppDefinition): void {\n    this.appRegistry.register(app)\n  }\n\n  unregisterApp(name: string): void {\n    // Terminate any running instances of this app\n    for (const instance of this.runningInstances.values()) {\n      if (instance.app.manifest.name === name) {\n        instance.terminate(0)\n      }\n    }\n    this.appRegistry.unregister(name)\n  }\n\n  getApp(name: string): CLIAppDefinition | undefined {\n    return this.appRegistry.get(name)\n  }\n\n  listApps(): CLIAppDefinition[] {\n    return this.appRegistry.list()\n  }\n\n  // ============================================\n  // App Execution\n  // ============================================\n\n  async launch(\n    name: string,\n    args: string[] = [],\n    flags: Record<string, string | boolean | number> = {}\n  ): Promise<CLIAppInstance> {\n    if (!this._initialized || !this.runtimeContext) {\n      throw new Error(\"CLI Plugin Host is not initialized\")\n    }\n\n    // Check concurrent app limit\n    if (this.runningInstances.size >= this.options.maxConcurrentApps) {\n      throw new Error(`Maximum concurrent apps (${this.options.maxConcurrentApps}) reached`)\n    }\n\n    // Get app definition\n    const app = this.appRegistry.get(name)\n    if (!app) {\n      throw new Error(`App \"${name}\" not found`)\n    }\n\n    // Get adapter for the app's library\n    const adapter = this.adapterRegistry.getAdapter(app.manifest.library)\n    if (!adapter) {\n      throw new Error(`No adapter registered for library: ${app.manifest.library}`)\n    }\n\n    // Check version compatibility\n    const compatibility = adapter.checkCompatibility(app.manifest.libraryVersion)\n    if (!compatibility.compatible) {\n      const warnings = compatibility.warnings?.join(\"; \") || \"Version mismatch\"\n      throw new Error(`Incompatible version: ${warnings}`)\n    }\n\n    // Create terminal bridge\n    const bridge = createExtendedCLITerminalBridge(this.runtimeContext)\n\n    // Create instance ID\n    const instanceId = generateId()\n\n    // Create app context\n    const context: CLIAppContext = {\n      terminal: bridge,\n      runtime: this.runtimeContext,\n      exit: (code = 0) => {\n        const instance = this.runningInstances.get(instanceId)\n        instance?.terminate(code)\n      },\n      args,\n      flags,\n      instanceId,\n      manifest: app.manifest,\n      suspend: () => {\n        const instance = this.runningInstances.get(instanceId)\n        instance?.suspend()\n      },\n      isForeground: () => this.foregroundInstanceId === instanceId,\n    }\n\n    // Call lifecycle hook\n    if (app.lifecycle?.onBeforeStart) {\n      await app.lifecycle.onBeforeStart(context)\n    }\n\n    // Create render instance\n    const props = { ...context }\n    if (adapter.transformProps) {\n      Object.assign(props, adapter.transformProps(props, app.manifest.libraryVersion))\n    }\n\n    const renderInstance = adapter.createRenderInstance(\n      app.Component as React.ComponentType<unknown>,\n      props,\n      bridge\n    )\n\n    // Create app instance\n    const instance = new CLIAppInstanceImpl(instanceId, app, renderInstance, bridge)\n    this.runningInstances.set(instanceId, instance)\n\n    // Set as foreground if no other foreground\n    if (!this.foregroundInstanceId) {\n      this.foregroundInstanceId = instanceId\n    }\n\n    // Subscribe to exit\n    instance.onExit((code) => {\n      this.runningInstances.delete(instanceId)\n      if (this.foregroundInstanceId === instanceId) {\n        this.foregroundInstanceId = null\n      }\n      this.terminateListeners.forEach((listener) => listener(instance, code))\n    })\n\n    // Subscribe to error\n    instance.onError((error) => {\n      this.errorListeners.forEach((listener) => listener(instance, error))\n    })\n\n    // Notify launch listeners\n    this.launchListeners.forEach((listener) => listener(instance))\n\n    return instance\n  }\n\n  getInstance(instanceId: string): CLIAppInstance | undefined {\n    return this.runningInstances.get(instanceId)\n  }\n\n  listRunningInstances(): CLIAppInstance[] {\n    return Array.from(this.runningInstances.values())\n  }\n\n  terminate(instanceId: string, code: number = 0): void {\n    const instance = this.runningInstances.get(instanceId)\n    instance?.terminate(code)\n  }\n\n  terminateAll(): void {\n    for (const instance of this.runningInstances.values()) {\n      instance.terminate(0)\n    }\n  }\n\n  getForegroundInstance(): CLIAppInstance | undefined {\n    if (!this.foregroundInstanceId) return undefined\n    return this.runningInstances.get(this.foregroundInstanceId)\n  }\n\n  bringToForeground(instanceId: string): void {\n    const instance = this.runningInstances.get(instanceId)\n    if (!instance) return\n\n    // Suspend current foreground\n    if (this.foregroundInstanceId && this.foregroundInstanceId !== instanceId) {\n      const current = this.runningInstances.get(this.foregroundInstanceId)\n      current?.suspend()\n    }\n\n    // Resume and set as foreground\n    instance.resume()\n    this.foregroundInstanceId = instanceId\n  }\n\n  // ============================================\n  // Adapter Management\n  // ============================================\n\n  registerAdapter(adapter: ICLIAdapter): void {\n    this.adapterRegistry.register(adapter)\n  }\n\n  getAdapter(library: CLILibrary): ICLIAdapter | undefined {\n    return this.adapterRegistry.getAdapter(library)\n  }\n\n  supportsLibrary(library: CLILibrary): boolean {\n    return this.adapterRegistry.supportsLibrary(library)\n  }\n\n  listSupportedLibraries(): CLILibrary[] {\n    return this.adapterRegistry.list().map((adapter) => adapter.library)\n  }\n\n  // ============================================\n  // Lifecycle\n  // ============================================\n\n  async initialize(context: OpenTUIRuntimeContext): Promise<void> {\n    if (this._initialized) return\n\n    this.runtimeContext = context\n\n    // Register default adapters\n    const inkAdapter = createInkAdapter()\n    await inkAdapter.initialize()\n    this.adapterRegistry.register(inkAdapter)\n\n    // Register custom adapters from options\n    for (const adapter of this.options.adapters) {\n      await adapter.initialize()\n      this.adapterRegistry.register(adapter)\n    }\n\n    this._initialized = true\n  }\n\n  isInitialized(): boolean {\n    return this._initialized\n  }\n\n  async destroy(): Promise<void> {\n    if (!this._initialized) return\n\n    // Terminate all running apps\n    this.terminateAll()\n\n    // Destroy all adapters\n    for (const adapter of this.adapterRegistry.list()) {\n      await adapter.destroy()\n    }\n\n    this._initialized = false\n    this.runtimeContext = null\n  }\n\n  // ============================================\n  // Events\n  // ============================================\n\n  onAppLaunched(callback: (instance: CLIAppInstance) => void): () => void {\n    this.launchListeners.add(callback)\n    return () => this.launchListeners.delete(callback)\n  }\n\n  onAppTerminated(callback: (instance: CLIAppInstance, code: number) => void): () => void {\n    this.terminateListeners.add(callback)\n    return () => this.terminateListeners.delete(callback)\n  }\n\n  onAppError(callback: (instance: CLIAppInstance, error: Error) => void): () => void {\n    this.errorListeners.add(callback)\n    return () => this.errorListeners.delete(callback)\n  }\n}\n\n/**\n * Create a new CLI Plugin Host\n */\nexport function createCLIPluginHost(options?: CLIPluginHostOptions): CLIPluginHost {\n  return new CLIPluginHostImpl(options)\n}\n\n// Export implementation for advanced use\nexport { CLIPluginHostImpl, CLIAppInstanceImpl }\n",
      "type": "registry:ui"
    }
  ]
}