{
  "name": "cli-version-negotiator",
  "type": "registry:lib",
  "title": "CLI Version Negotiator",
  "description": "Semver-based version compatibility and feature negotiation for CLI plugins.",
  "dependencies": [],
  "registryDependencies": [
    "cli-plugin-types"
  ],
  "files": [
    {
      "path": "lib/opentui/plugins/cli/adapters/version-negotiator.ts",
      "content": "// Version Negotiator for CLI Plugin Framework\n// Handles semver-based version compatibility and feature negotiation\n\nimport type { \n  CLILibrary, \n  VersionRange, \n  VersionCompatibility, \n  CLIFeature,\n  VersionFeatureMap \n} from \"../types\"\n\n/** Parsed semantic version */\ninterface ParsedVersion {\n  major: number\n  minor: number\n  patch: number\n  prerelease?: string\n  build?: string\n}\n\n/** Version range operator */\ntype RangeOperator = \"=\" | \">\" | \">=\" | \"<\" | \"<=\" | \"^\" | \"~\"\n\n/** Parsed version range */\ninterface ParsedRange {\n  operator: RangeOperator\n  version: ParsedVersion\n}\n\n/**\n * Parse a semantic version string\n */\nexport function parseVersion(version: string): ParsedVersion {\n  const cleanVersion = version.replace(/^[v=]/, \"\").trim()\n  \n  // Match semver pattern: major.minor.patch[-prerelease][+build]\n  const match = cleanVersion.match(\n    /^(\\d+)\\.(\\d+)\\.(\\d+)(?:-([a-zA-Z0-9.-]+))?(?:\\+([a-zA-Z0-9.-]+))?$/\n  )\n  \n  if (!match) {\n    throw new Error(`Invalid version format: ${version}`)\n  }\n  \n  return {\n    major: parseInt(match[1], 10),\n    minor: parseInt(match[2], 10),\n    patch: parseInt(match[3], 10),\n    prerelease: match[4],\n    build: match[5],\n  }\n}\n\n/**\n * Compare two versions\n * Returns: -1 if a < b, 0 if a = b, 1 if a > b\n */\nexport function compareVersions(a: ParsedVersion, b: ParsedVersion): number {\n  // Compare major\n  if (a.major !== b.major) return a.major < b.major ? -1 : 1\n  \n  // Compare minor\n  if (a.minor !== b.minor) return a.minor < b.minor ? -1 : 1\n  \n  // Compare patch\n  if (a.patch !== b.patch) return a.patch < b.patch ? -1 : 1\n  \n  // Prerelease versions have lower precedence\n  if (a.prerelease && !b.prerelease) return -1\n  if (!a.prerelease && b.prerelease) return 1\n  if (a.prerelease && b.prerelease) {\n    return a.prerelease < b.prerelease ? -1 : a.prerelease > b.prerelease ? 1 : 0\n  }\n  \n  return 0\n}\n\n/**\n * Parse a version range string\n */\nexport function parseRange(range: string): ParsedRange[] {\n  const ranges: ParsedRange[] = []\n  \n  // Split on spaces for multiple conditions (AND)\n  const parts = range.trim().split(/\\s+/)\n  \n  for (const part of parts) {\n    // Check for range operators\n    const match = part.match(/^([><=^~]*)(.+)$/)\n    if (!match) continue\n    \n    let operator: RangeOperator = \"=\"\n    const op = match[1] || \"=\"\n    \n    switch (op) {\n      case \">=\": operator = \">=\"; break\n      case \">\": operator = \">\"; break\n      case \"<=\": operator = \"<=\"; break\n      case \"<\": operator = \"<\"; break\n      case \"^\": operator = \"^\"; break\n      case \"~\": operator = \"~\"; break\n      default: operator = \"=\"; break\n    }\n    \n    try {\n      ranges.push({\n        operator,\n        version: parseVersion(match[2]),\n      })\n    } catch {\n      // Skip invalid versions\n    }\n  }\n  \n  return ranges\n}\n\n/**\n * Check if a version satisfies a single range condition\n */\nfunction satisfiesCondition(version: ParsedVersion, condition: ParsedRange): boolean {\n  const cmp = compareVersions(version, condition.version)\n  \n  switch (condition.operator) {\n    case \"=\":\n      return cmp === 0\n    case \">\":\n      return cmp > 0\n    case \">=\":\n      return cmp >= 0\n    case \"<\":\n      return cmp < 0\n    case \"<=\":\n      return cmp <= 0\n    case \"^\":\n      // Compatible with version (major must match, minor/patch can be higher)\n      if (condition.version.major === 0) {\n        // For 0.x.x, minor must match\n        return (\n          version.major === condition.version.major &&\n          version.minor === condition.version.minor &&\n          version.patch >= condition.version.patch\n        )\n      }\n      return (\n        version.major === condition.version.major &&\n        (version.minor > condition.version.minor ||\n          (version.minor === condition.version.minor &&\n            version.patch >= condition.version.patch))\n      )\n    case \"~\":\n      // Approximately equivalent (patch-level changes allowed)\n      return (\n        version.major === condition.version.major &&\n        version.minor === condition.version.minor &&\n        version.patch >= condition.version.patch\n      )\n    default:\n      return false\n  }\n}\n\n/**\n * Check if a version satisfies a range\n */\nexport function satisfiesRange(version: string, range: VersionRange): boolean {\n  try {\n    const parsed = parseVersion(version)\n    const conditions = parseRange(range)\n    \n    // All conditions must be satisfied (AND logic)\n    return conditions.every((condition) => satisfiesCondition(parsed, condition))\n  } catch {\n    return false\n  }\n}\n\n/**\n * Version Negotiator class\n */\nexport class VersionNegotiator {\n  private versionFeatures: Map<CLILibrary, VersionFeatureMap[]> = new Map()\n  private shimRegistry: Map<string, string[]> = new Map()\n\n  constructor() {\n    // Initialize with default feature maps\n    this.initializeDefaultFeatures()\n  }\n\n  /**\n   * Initialize default feature maps for supported libraries\n   */\n  private initializeDefaultFeatures(): void {\n    // Ink v6.x features\n    this.versionFeatures.set(\"ink\", [\n      {\n        version: \"6.6.0\",\n        features: [\n          \"useInput\",\n          \"useStdin\",\n          \"useStdout\",\n          \"useFocus\",\n          \"flexbox\",\n          \"colors16\",\n          \"colors256\",\n          \"unicode\",\n          \"boxDrawing\",\n        ],\n      },\n      {\n        version: \"6.7.0\",\n        features: [\n          \"useInput\",\n          \"useStdin\",\n          \"useStdout\",\n          \"useFocus\",\n          \"useFocusManager\",\n          \"measureElement\",\n          \"flexbox\",\n          \"colors16\",\n          \"colors256\",\n          \"trueColor\",\n          \"unicode\",\n          \"boxDrawing\",\n        ],\n      },\n      {\n        version: \"6.8.0\",\n        features: [\n          \"useInput\",\n          \"useStdin\",\n          \"useStdout\",\n          \"useFocus\",\n          \"useFocusManager\",\n          \"measureElement\",\n          \"staticOutput\",\n          \"flexbox\",\n          \"colors16\",\n          \"colors256\",\n          \"trueColor\",\n          \"unicode\",\n          \"mouse\",\n          \"boxDrawing\",\n        ],\n      },\n    ])\n\n    // Pastel v4.x features (future)\n    this.versionFeatures.set(\"pastel\", [\n      {\n        version: \"4.0.0\",\n        features: [\n          \"useInput\",\n          \"flexbox\",\n          \"colors16\",\n          \"colors256\",\n          \"trueColor\",\n          \"unicode\",\n          \"boxDrawing\",\n        ],\n      },\n    ])\n  }\n\n  /**\n   * Register feature support for a library version\n   */\n  registerVersion(library: CLILibrary, version: string, features: CLIFeature[]): void {\n    const existing = this.versionFeatures.get(library) || []\n    const versionIndex = existing.findIndex((v) => v.version === version)\n    \n    if (versionIndex >= 0) {\n      existing[versionIndex] = { version, features }\n    } else {\n      existing.push({ version, features })\n      // Sort by version\n      existing.sort((a, b) => compareVersions(parseVersion(a.version), parseVersion(b.version)))\n    }\n    \n    this.versionFeatures.set(library, existing)\n  }\n\n  /**\n   * Register shims needed for version compatibility\n   */\n  registerShim(fromVersion: string, toVersion: string, shims: string[]): void {\n    const key = `${fromVersion}->${toVersion}`\n    this.shimRegistry.set(key, shims)\n  }\n\n  /**\n   * Negotiate the best compatible version\n   */\n  negotiate(\n    library: CLILibrary,\n    requestedRange: VersionRange,\n    availableVersion: string\n  ): VersionCompatibility {\n    const warnings: string[] = []\n    const requiredShims: string[] = []\n    const missingFeatures: CLIFeature[] = []\n\n    // Check if available version satisfies the requested range\n    const compatible = satisfiesRange(availableVersion, requestedRange)\n\n    if (!compatible) {\n      // Try to find what shims might help\n      const requestedParsed = parseRange(requestedRange)\n      if (requestedParsed.length > 0) {\n        const requestedVersion = `${requestedParsed[0].version.major}.${requestedParsed[0].version.minor}.${requestedParsed[0].version.patch}`\n        const shimKey = `${requestedVersion}->${availableVersion}`\n        const shims = this.shimRegistry.get(shimKey)\n        if (shims) {\n          requiredShims.push(...shims)\n          warnings.push(`Version mismatch: requested ${requestedRange}, available ${availableVersion}. Shims may help.`)\n        } else {\n          warnings.push(`Version mismatch: requested ${requestedRange}, available ${availableVersion}. No shims available.`)\n        }\n      }\n    }\n\n    // Check for missing features\n    const libraryVersions = this.versionFeatures.get(library) || []\n    const requestedFeatures = this.getFeaturesForVersionInternal(libraryVersions, requestedRange)\n    const availableFeatures = this.getFeaturesForVersionInternal(libraryVersions, availableVersion)\n\n    for (const feature of requestedFeatures) {\n      if (!availableFeatures.includes(feature)) {\n        missingFeatures.push(feature)\n      }\n    }\n\n    if (missingFeatures.length > 0) {\n      warnings.push(`Missing features in ${availableVersion}: ${missingFeatures.join(\", \")}`)\n    }\n\n    return {\n      compatible,\n      negotiatedVersion: availableVersion,\n      warnings: warnings.length > 0 ? warnings : undefined,\n      requiredShims: requiredShims.length > 0 ? requiredShims : undefined,\n      missingFeatures: missingFeatures.length > 0 ? missingFeatures : undefined,\n    }\n  }\n\n  /**\n   * Get features for a specific version\n   */\n  private getFeaturesForVersionInternal(\n    versions: VersionFeatureMap[],\n    versionOrRange: string\n  ): CLIFeature[] {\n    // Find the best matching version\n    for (let i = versions.length - 1; i >= 0; i--) {\n      if (satisfiesRange(versions[i].version, versionOrRange)) {\n        return versions[i].features\n      }\n    }\n    \n    // If no exact match, return features from the highest compatible version\n    for (let i = versions.length - 1; i >= 0; i--) {\n      try {\n        const vParsed = parseVersion(versions[i].version)\n        const ranges = parseRange(versionOrRange)\n        if (ranges.length > 0) {\n          const cmp = compareVersions(vParsed, ranges[0].version)\n          if (cmp >= 0) {\n            return versions[i].features\n          }\n        }\n      } catch {\n        continue\n      }\n    }\n    \n    return []\n  }\n\n  /**\n   * Get features available for a library at a specific version\n   */\n  getFeaturesForVersion(library: CLILibrary, version: string): CLIFeature[] {\n    const versions = this.versionFeatures.get(library) || []\n    return this.getFeaturesForVersionInternal(versions, version)\n  }\n\n  /**\n   * Check if a feature is available for a library at a specific version\n   */\n  isFeatureAvailable(library: CLILibrary, version: string, feature: CLIFeature): boolean {\n    const features = this.getFeaturesForVersion(library, version)\n    return features.includes(feature)\n  }\n\n  /**\n   * Get required shims for version gap\n   */\n  getRequiredShims(fromVersion: string, toVersion: string): string[] {\n    const key = `${fromVersion}->${toVersion}`\n    return this.shimRegistry.get(key) || []\n  }\n\n  /**\n   * Get all registered versions for a library\n   */\n  getRegisteredVersions(library: CLILibrary): string[] {\n    const versions = this.versionFeatures.get(library) || []\n    return versions.map((v) => v.version)\n  }\n}\n\n// Export singleton instance\nexport const versionNegotiator = new VersionNegotiator()\n\n// Export utility functions\nexport { parseVersion, compareVersions, satisfiesRange }\n",
      "type": "registry:ui"
    }
  ]
}