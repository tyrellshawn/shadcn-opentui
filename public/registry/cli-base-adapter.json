{
  "name": "cli-base-adapter",
  "type": "registry:lib",
  "title": "CLI Base Adapter",
  "description": "Abstract base class for CLI library adapters.",
  "dependencies": [],
  "registryDependencies": [
    "cli-plugin-types",
    "cli-version-negotiator"
  ],
  "files": [
    {
      "path": "lib/opentui/plugins/cli/adapters/base-adapter.ts",
      "content": "// Base Adapter for CLI Plugin Framework\n// Abstract base class that all library adapters extend\n\nimport type {\n  ICLIAdapter,\n  CLILibrary,\n  VersionRange,\n  VersionCompatibility,\n  CLIFeature,\n  CLITerminalBridge,\n  CLIRenderInstance,\n} from \"../types\"\nimport { versionNegotiator, satisfiesRange } from \"./version-negotiator\"\n\n/**\n * Generate a unique ID\n */\nfunction generateId(): string {\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n}\n\n/**\n * Abstract base adapter class\n * Provides common functionality for all CLI library adapters\n */\nexport abstract class BaseCLIAdapter implements ICLIAdapter {\n  abstract readonly library: CLILibrary\n  abstract readonly adapterVersion: string\n  abstract readonly supportedVersions: VersionRange\n\n  protected initialized = false\n  protected activeInstances = new Map<string, CLIRenderInstance>()\n\n  /**\n   * Initialize the adapter\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return\n    }\n    await this.doInitialize()\n    this.initialized = true\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async destroy(): Promise<void> {\n    if (!this.initialized) {\n      return\n    }\n    \n    // Unmount all active instances\n    for (const instance of this.activeInstances.values()) {\n      try {\n        instance.unmount()\n      } catch {\n        // Ignore unmount errors during cleanup\n      }\n    }\n    this.activeInstances.clear()\n    \n    await this.doDestroy()\n    this.initialized = false\n  }\n\n  /**\n   * Check version compatibility\n   */\n  checkCompatibility(requestedVersion: string): VersionCompatibility {\n    return versionNegotiator.negotiate(\n      this.library,\n      requestedVersion,\n      this.getAdapterLibraryVersion()\n    )\n  }\n\n  /**\n   * Create a render instance\n   */\n  createRenderInstance(\n    component: React.ComponentType<unknown>,\n    props: Record<string, unknown>,\n    bridge: CLITerminalBridge\n  ): CLIRenderInstance {\n    if (!this.initialized) {\n      throw new Error(`Adapter for ${this.library} is not initialized`)\n    }\n\n    const id = generateId()\n    const instance = this.doCreateRenderInstance(id, component, props, bridge)\n    this.activeInstances.set(id, instance)\n\n    // Remove from tracking when unmounted\n    const originalUnmount = instance.unmount.bind(instance)\n    instance.unmount = () => {\n      this.activeInstances.delete(id)\n      originalUnmount()\n    }\n\n    return instance\n  }\n\n  /**\n   * Check if a feature is supported\n   */\n  supportsFeature(feature: CLIFeature): boolean {\n    return this.getSupportedFeatures().includes(feature)\n  }\n\n  /**\n   * Get features for a specific version\n   */\n  getFeaturesForVersion(version: string): CLIFeature[] {\n    if (!satisfiesRange(version, this.supportedVersions)) {\n      return []\n    }\n    return versionNegotiator.getFeaturesForVersion(this.library, version)\n  }\n\n  /**\n   * Transform props for version compatibility\n   */\n  transformProps?(props: Record<string, unknown>, targetVersion: string): Record<string, unknown> {\n    // Default: no transformation\n    return props\n  }\n\n  // ============================================\n  // Abstract methods to be implemented by subclasses\n  // ============================================\n\n  /**\n   * Perform adapter-specific initialization\n   */\n  protected abstract doInitialize(): Promise<void>\n\n  /**\n   * Perform adapter-specific cleanup\n   */\n  protected abstract doDestroy(): Promise<void>\n\n  /**\n   * Create an adapter-specific render instance\n   */\n  protected abstract doCreateRenderInstance(\n    id: string,\n    component: React.ComponentType<unknown>,\n    props: Record<string, unknown>,\n    bridge: CLITerminalBridge\n  ): CLIRenderInstance\n\n  /**\n   * Get the library version this adapter uses\n   */\n  protected abstract getAdapterLibraryVersion(): string\n\n  /**\n   * Get list of supported features\n   */\n  protected abstract getSupportedFeatures(): CLIFeature[]\n}\n\n/**\n * Base render instance class\n */\nexport abstract class BaseRenderInstance implements CLIRenderInstance {\n  readonly id: string\n  protected _isActive = true\n  protected _isPaused = false\n  protected exitCode: number | null = null\n  protected exitResolve: ((code: number) => void) | null = null\n\n  constructor(id: string) {\n    this.id = id\n  }\n\n  /**\n   * Re-render with new props\n   */\n  abstract rerender(props?: Record<string, unknown>): void\n\n  /**\n   * Unmount the component\n   */\n  unmount(): void {\n    if (!this._isActive) return\n    this._isActive = false\n    this.doUnmount()\n    if (this.exitResolve) {\n      this.exitResolve(this.exitCode ?? 0)\n    }\n  }\n\n  /**\n   * Wait for exit\n   */\n  waitUntilExit(): Promise<number> {\n    if (!this._isActive) {\n      return Promise.resolve(this.exitCode ?? 0)\n    }\n    return new Promise((resolve) => {\n      this.exitResolve = resolve\n    })\n  }\n\n  /**\n   * Clear rendered content\n   */\n  abstract clear(): void\n\n  /**\n   * Pause rendering\n   */\n  pause(): void {\n    if (!this._isActive) return\n    this._isPaused = true\n    this.doPause()\n  }\n\n  /**\n   * Resume rendering\n   */\n  resume(): void {\n    if (!this._isActive) return\n    this._isPaused = false\n    this.doResume()\n  }\n\n  /**\n   * Check if instance is active\n   */\n  isActive(): boolean {\n    return this._isActive\n  }\n\n  /**\n   * Set exit code\n   */\n  protected setExitCode(code: number): void {\n    this.exitCode = code\n  }\n\n  // Abstract methods for subclasses\n  protected abstract doUnmount(): void\n  protected abstract doPause(): void\n  protected abstract doResume(): void\n}\n\nexport { generateId }\n",
      "type": "registry:ui"
    }
  ]
}