{
  "name": "cli-app-registry",
  "type": "registry:lib",
  "title": "CLI App Registry",
  "description": "Registry for managing CLI application registration and lookup.",
  "dependencies": [],
  "registryDependencies": [
    "cli-plugin-types"
  ],
  "files": [
    {
      "path": "lib/opentui/plugins/cli/cli-app-registry.ts",
      "content": "// CLI App Registry\n// Manages registration and lookup of CLI applications\n\nimport type { \n  CLIAppDefinition, \n  CLIAppRegistry, \n  CLILibrary,\n  CLIAdapterRegistry,\n  ICLIAdapter,\n  VersionRange,\n} from \"./types\"\n\n/**\n * Implementation of CLIAppRegistry\n */\nclass CLIAppRegistryImpl implements CLIAppRegistry {\n  private apps = new Map<string, CLIAppDefinition>()\n  private aliasMap = new Map<string, string>() // alias -> name\n\n  register(app: CLIAppDefinition): void {\n    if (!app.manifest.name) {\n      throw new Error(\"App manifest must have a name\")\n    }\n\n    const name = app.manifest.name\n\n    if (this.apps.has(name)) {\n      throw new Error(`App \"${name}\" is already registered`)\n    }\n\n    this.apps.set(name, app)\n\n    // Register entry command as alias if specified\n    if (app.manifest.entryCommand && app.manifest.entryCommand !== name) {\n      this.aliasMap.set(app.manifest.entryCommand, name)\n    }\n\n    // Register command aliases\n    if (app.commands) {\n      for (const cmd of app.commands) {\n        if (cmd.aliases) {\n          for (const alias of cmd.aliases) {\n            const aliasKey = `${name}:${alias}`\n            this.aliasMap.set(aliasKey, `${name}:${cmd.name}`)\n          }\n        }\n      }\n    }\n\n    // Call lifecycle hook\n    if (app.lifecycle?.onRegister) {\n      app.lifecycle.onRegister(this)\n    }\n  }\n\n  unregister(name: string): void {\n    const app = this.apps.get(name)\n    if (!app) return\n\n    // Remove aliases\n    if (app.manifest.entryCommand) {\n      this.aliasMap.delete(app.manifest.entryCommand)\n    }\n\n    if (app.commands) {\n      for (const cmd of app.commands) {\n        if (cmd.aliases) {\n          for (const alias of cmd.aliases) {\n            this.aliasMap.delete(`${name}:${alias}`)\n          }\n        }\n      }\n    }\n\n    this.apps.delete(name)\n  }\n\n  get(name: string): CLIAppDefinition | undefined {\n    // Check direct name first\n    if (this.apps.has(name)) {\n      return this.apps.get(name)\n    }\n\n    // Check aliases\n    const resolvedName = this.aliasMap.get(name)\n    if (resolvedName) {\n      return this.apps.get(resolvedName)\n    }\n\n    return undefined\n  }\n\n  list(): CLIAppDefinition[] {\n    return Array.from(this.apps.values())\n  }\n\n  has(name: string): boolean {\n    return this.apps.has(name) || this.aliasMap.has(name)\n  }\n\n  getByLibrary(library: CLILibrary): CLIAppDefinition[] {\n    return this.list().filter((app) => app.manifest.library === library)\n  }\n\n  search(query: string): CLIAppDefinition[] {\n    const lowerQuery = query.toLowerCase()\n    \n    return this.list().filter((app) => {\n      const { name, description, keywords } = app.manifest\n      \n      // Search in name\n      if (name.toLowerCase().includes(lowerQuery)) return true\n      \n      // Search in description\n      if (description?.toLowerCase().includes(lowerQuery)) return true\n      \n      // Search in keywords\n      if (keywords?.some((kw) => kw.toLowerCase().includes(lowerQuery))) return true\n      \n      // Search in commands\n      if (app.commands?.some((cmd) => \n        cmd.name.toLowerCase().includes(lowerQuery) ||\n        cmd.description.toLowerCase().includes(lowerQuery)\n      )) return true\n      \n      return false\n    })\n  }\n\n  count(): number {\n    return this.apps.size\n  }\n\n  /**\n   * Clear all registered apps\n   */\n  clear(): void {\n    this.apps.clear()\n    this.aliasMap.clear()\n  }\n\n  /**\n   * Get all registered app names\n   */\n  getNames(): string[] {\n    return Array.from(this.apps.keys())\n  }\n\n  /**\n   * Export registry data for persistence\n   */\n  export(): { apps: CLIAppDefinition[]; aliases: Record<string, string> } {\n    return {\n      apps: this.list(),\n      aliases: Object.fromEntries(this.aliasMap),\n    }\n  }\n}\n\n/**\n * Implementation of CLIAdapterRegistry\n */\nclass CLIAdapterRegistryImpl implements CLIAdapterRegistry {\n  private adapters = new Map<CLILibrary, ICLIAdapter>()\n\n  register(adapter: ICLIAdapter): void {\n    const library = adapter.library\n    \n    if (this.adapters.has(library)) {\n      console.warn(`Overwriting existing adapter for library: ${library}`)\n    }\n    \n    this.adapters.set(library, adapter)\n  }\n\n  unregister(library: CLILibrary): void {\n    this.adapters.delete(library)\n  }\n\n  getAdapter(library: CLILibrary): ICLIAdapter | undefined {\n    return this.adapters.get(library)\n  }\n\n  list(): ICLIAdapter[] {\n    return Array.from(this.adapters.values())\n  }\n\n  supportsLibrary(library: CLILibrary): boolean {\n    return this.adapters.has(library)\n  }\n\n  getSupportedVersions(library: CLILibrary): VersionRange | undefined {\n    const adapter = this.adapters.get(library)\n    return adapter?.supportedVersions\n  }\n\n  /**\n   * Clear all registered adapters\n   */\n  clear(): void {\n    this.adapters.clear()\n  }\n\n  /**\n   * Get count of registered adapters\n   */\n  count(): number {\n    return this.adapters.size\n  }\n}\n\n/**\n * Create a new CLI app registry instance\n */\nexport function createCLIAppRegistry(): CLIAppRegistry {\n  return new CLIAppRegistryImpl()\n}\n\n/**\n * Create a new CLI adapter registry instance\n */\nexport function createCLIAdapterRegistry(): CLIAdapterRegistry {\n  return new CLIAdapterRegistryImpl()\n}\n\n// Export implementation classes for advanced use\nexport { CLIAppRegistryImpl, CLIAdapterRegistryImpl }\n",
      "type": "registry:ui"
    }
  ]
}