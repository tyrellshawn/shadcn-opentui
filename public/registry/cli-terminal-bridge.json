{
  "name": "cli-terminal-bridge",
  "type": "registry:lib",
  "title": "CLI Terminal Bridge",
  "description": "Bridge between CLI apps and OpenTUI terminal I/O.",
  "dependencies": [],
  "registryDependencies": [
    "cli-plugin-types"
  ],
  "files": [
    {
      "path": "lib/opentui/plugins/cli/cli-terminal-bridge.ts",
      "content": "// CLI Terminal Bridge Implementation\n// Bridges CLI apps to OpenTUI terminal I/O\n\nimport type { \n  CLITerminalBridge, \n  TerminalDimensions, \n  KeyModifiers, \n  StyledContent \n} from \"./types\"\nimport type { OpenTUIRuntimeContext, TerminalLine } from \"../../types\"\n\n/** Configuration for terminal bridge */\nexport interface CLITerminalBridgeConfig {\n  /** Initial terminal dimensions */\n  initialDimensions?: TerminalDimensions\n  /** Default prompt string */\n  defaultPrompt?: string\n  /** Enable input buffering */\n  bufferInput?: boolean\n  /** Enable ANSI escape code processing */\n  processAnsiCodes?: boolean\n}\n\n/** Event types for the terminal bridge */\nexport type TerminalBridgeEventType = \"resize\" | \"keypress\" | \"input\" | \"output\"\n\n/** Event listener function */\ntype EventListener<T> = (data: T) => void\n\n/**\n * Creates a terminal bridge that connects CLI apps to OpenTUI runtime\n */\nexport function createCLITerminalBridge(\n  runtime: OpenTUIRuntimeContext,\n  config: CLITerminalBridgeConfig = {}\n): CLITerminalBridge {\n  const {\n    initialDimensions = { columns: 80, rows: 24 },\n    defaultPrompt = \"> \",\n    processAnsiCodes = true,\n  } = config\n\n  // Internal state\n  let currentDimensions = { ...initialDimensions }\n  let currentPrompt = defaultPrompt\n  let cursorPosition = { x: 0, y: 0 }\n  let cursorVisible = true\n  let inputBuffer = \"\"\n  let inputResolve: ((value: string) => void) | null = null\n\n  // Event listeners\n  const resizeListeners = new Set<EventListener<TerminalDimensions>>()\n  const keypressListeners = new Set<EventListener<{ key: string; modifiers: KeyModifiers }>>()\n\n  /**\n   * Process ANSI escape codes and convert to styled content\n   */\n  function processAnsiContent(content: string): string {\n    if (!processAnsiCodes) return content\n    \n    // Remove ANSI escape codes for now - they'll be processed by the terminal component\n    // In a full implementation, this would parse and convert to terminal-compatible styling\n    return content.replace(/\\x1b\\[[0-9;]*m/g, \"\")\n  }\n\n  /**\n   * Convert styled content to terminal-compatible string\n   */\n  function styledContentToString(content: StyledContent): string {\n    // Build ANSI escape sequence\n    const codes: number[] = []\n    \n    if (content.bold) codes.push(1)\n    if (content.dim) codes.push(2)\n    if (content.italic) codes.push(3)\n    if (content.underline) codes.push(4)\n    if (content.inverse) codes.push(7)\n    if (content.strikethrough) codes.push(9)\n    \n    // Color mapping (basic 16 colors)\n    const colorMap: Record<string, number> = {\n      black: 30, red: 31, green: 32, yellow: 33,\n      blue: 34, magenta: 35, cyan: 36, white: 37,\n      brightBlack: 90, brightRed: 91, brightGreen: 92, brightYellow: 93,\n      brightBlue: 94, brightMagenta: 95, brightCyan: 96, brightWhite: 97,\n    }\n    \n    const bgColorMap: Record<string, number> = {\n      black: 40, red: 41, green: 42, yellow: 43,\n      blue: 44, magenta: 45, cyan: 46, white: 47,\n      brightBlack: 100, brightRed: 101, brightGreen: 102, brightYellow: 103,\n      brightBlue: 104, brightMagenta: 105, brightCyan: 106, brightWhite: 107,\n    }\n    \n    if (content.color && colorMap[content.color]) {\n      codes.push(colorMap[content.color])\n    }\n    \n    if (content.backgroundColor && bgColorMap[content.backgroundColor]) {\n      codes.push(bgColorMap[content.backgroundColor])\n    }\n    \n    if (codes.length === 0) {\n      return content.text\n    }\n    \n    // Return text with ANSI codes (reset at end)\n    return `\\x1b[${codes.join(\";\")}m${content.text}\\x1b[0m`\n  }\n\n  /**\n   * Parse keyboard modifiers from event\n   */\n  function parseModifiers(event: KeyboardEvent): KeyModifiers {\n    return {\n      ctrl: event.ctrlKey,\n      alt: event.altKey,\n      shift: event.shiftKey,\n      meta: event.metaKey,\n    }\n  }\n\n  /**\n   * Handle global keypress events\n   */\n  function handleKeyPress(key: string, modifiers: KeyModifiers): void {\n    // Notify all listeners\n    keypressListeners.forEach((listener) => {\n      listener({ key, modifiers })\n    })\n\n    // Handle input if waiting for input\n    if (inputResolve) {\n      if (key === \"Enter\") {\n        const value = inputBuffer\n        inputBuffer = \"\"\n        inputResolve(value)\n        inputResolve = null\n      } else if (key === \"Backspace\") {\n        inputBuffer = inputBuffer.slice(0, -1)\n      } else if (key.length === 1) {\n        inputBuffer += key\n      }\n    }\n  }\n\n  // The bridge implementation\n  const bridge: CLITerminalBridge = {\n    write(content: string): void {\n      const processed = processAnsiContent(content)\n      // Use addLine without newline - this writes inline\n      runtime.addLine(processed, \"output\")\n    },\n\n    writeLine(content: string, type: TerminalLine[\"type\"] = \"output\"): void {\n      const processed = processAnsiContent(content)\n      runtime.addLine(processed, type)\n    },\n\n    clear(): void {\n      runtime.clearLines()\n      cursorPosition = { x: 0, y: 0 }\n    },\n\n    updateLine(content: string): void {\n      const processed = processAnsiContent(content)\n      runtime.updateLastLine(processed)\n    },\n\n    setPrompt(prompt: string): void {\n      currentPrompt = prompt\n      // Note: The actual prompt update would be handled by the terminal component\n    },\n\n    async requestInput(prompt?: string): Promise<string> {\n      if (prompt) {\n        runtime.addLine(prompt, \"output\")\n      }\n      \n      return new Promise((resolve) => {\n        inputResolve = resolve\n        inputBuffer = \"\"\n      })\n    },\n\n    get dimensions(): TerminalDimensions {\n      return { ...currentDimensions }\n    },\n\n    onResize(callback: (dims: TerminalDimensions) => void): () => void {\n      resizeListeners.add(callback)\n      return () => resizeListeners.delete(callback)\n    },\n\n    onKeyPress(callback: (key: string, modifiers: KeyModifiers) => void): () => void {\n      const wrappedCallback = ({ key, modifiers }: { key: string; modifiers: KeyModifiers }) => {\n        callback(key, modifiers)\n      }\n      keypressListeners.add(wrappedCallback)\n      return () => keypressListeners.delete(wrappedCallback)\n    },\n\n    renderStyled(content: StyledContent): void {\n      const styledString = styledContentToString(content)\n      this.write(styledString)\n    },\n\n    getCursorPosition(): { x: number; y: number } {\n      return { ...cursorPosition }\n    },\n\n    setCursorPosition(x: number, y: number): void {\n      cursorPosition = { x: Math.max(0, x), y: Math.max(0, y) }\n    },\n\n    setCursorVisible(visible: boolean): void {\n      cursorVisible = visible\n    },\n  }\n\n  return bridge\n}\n\n/**\n * Extended bridge with additional control methods\n */\nexport interface ExtendedCLITerminalBridge extends CLITerminalBridge {\n  /** Update terminal dimensions (called by resize observer) */\n  setDimensions(dimensions: TerminalDimensions): void\n  /** Dispatch a keypress event */\n  dispatchKeyPress(key: string, modifiers: KeyModifiers): void\n  /** Get current prompt */\n  getPrompt(): string\n  /** Check if currently waiting for input */\n  isWaitingForInput(): boolean\n  /** Cancel pending input request */\n  cancelInput(): void\n}\n\n/**\n * Creates an extended terminal bridge with additional control methods\n */\nexport function createExtendedCLITerminalBridge(\n  runtime: OpenTUIRuntimeContext,\n  config: CLITerminalBridgeConfig = {}\n): ExtendedCLITerminalBridge {\n  const {\n    initialDimensions = { columns: 80, rows: 24 },\n    defaultPrompt = \"> \",\n    processAnsiCodes = true,\n  } = config\n\n  // Internal state\n  let currentDimensions = { ...initialDimensions }\n  let currentPrompt = defaultPrompt\n  let cursorPosition = { x: 0, y: 0 }\n  let cursorVisible = true\n  let inputBuffer = \"\"\n  let inputResolve: ((value: string) => void) | null = null\n  let inputReject: ((reason?: unknown) => void) | null = null\n\n  // Event listeners\n  const resizeListeners = new Set<EventListener<TerminalDimensions>>()\n  const keypressListeners = new Set<EventListener<{ key: string; modifiers: KeyModifiers }>>()\n\n  function processAnsiContent(content: string): string {\n    if (!processAnsiCodes) return content\n    return content.replace(/\\x1b\\[[0-9;]*m/g, \"\")\n  }\n\n  function styledContentToString(content: StyledContent): string {\n    const codes: number[] = []\n    \n    if (content.bold) codes.push(1)\n    if (content.dim) codes.push(2)\n    if (content.italic) codes.push(3)\n    if (content.underline) codes.push(4)\n    if (content.inverse) codes.push(7)\n    if (content.strikethrough) codes.push(9)\n    \n    const colorMap: Record<string, number> = {\n      black: 30, red: 31, green: 32, yellow: 33,\n      blue: 34, magenta: 35, cyan: 36, white: 37,\n      brightBlack: 90, brightRed: 91, brightGreen: 92, brightYellow: 93,\n      brightBlue: 94, brightMagenta: 95, brightCyan: 96, brightWhite: 97,\n    }\n    \n    const bgColorMap: Record<string, number> = {\n      black: 40, red: 41, green: 42, yellow: 43,\n      blue: 44, magenta: 45, cyan: 46, white: 47,\n      brightBlack: 100, brightRed: 101, brightGreen: 102, brightYellow: 103,\n      brightBlue: 104, brightMagenta: 105, brightCyan: 106, brightWhite: 107,\n    }\n    \n    if (content.color && colorMap[content.color]) {\n      codes.push(colorMap[content.color])\n    }\n    \n    if (content.backgroundColor && bgColorMap[content.backgroundColor]) {\n      codes.push(bgColorMap[content.backgroundColor])\n    }\n    \n    if (codes.length === 0) {\n      return content.text\n    }\n    \n    return `\\x1b[${codes.join(\";\")}m${content.text}\\x1b[0m`\n  }\n\n  const bridge: ExtendedCLITerminalBridge = {\n    write(content: string): void {\n      const processed = processAnsiContent(content)\n      runtime.addLine(processed, \"output\")\n    },\n\n    writeLine(content: string, type: TerminalLine[\"type\"] = \"output\"): void {\n      const processed = processAnsiContent(content)\n      runtime.addLine(processed, type)\n    },\n\n    clear(): void {\n      runtime.clearLines()\n      cursorPosition = { x: 0, y: 0 }\n    },\n\n    updateLine(content: string): void {\n      const processed = processAnsiContent(content)\n      runtime.updateLastLine(processed)\n    },\n\n    setPrompt(prompt: string): void {\n      currentPrompt = prompt\n    },\n\n    async requestInput(prompt?: string): Promise<string> {\n      if (prompt) {\n        runtime.addLine(prompt, \"output\")\n      }\n      \n      return new Promise((resolve, reject) => {\n        inputResolve = resolve\n        inputReject = reject\n        inputBuffer = \"\"\n      })\n    },\n\n    get dimensions(): TerminalDimensions {\n      return { ...currentDimensions }\n    },\n\n    onResize(callback: (dims: TerminalDimensions) => void): () => void {\n      resizeListeners.add(callback)\n      return () => resizeListeners.delete(callback)\n    },\n\n    onKeyPress(callback: (key: string, modifiers: KeyModifiers) => void): () => void {\n      const wrappedCallback = ({ key, modifiers }: { key: string; modifiers: KeyModifiers }) => {\n        callback(key, modifiers)\n      }\n      keypressListeners.add(wrappedCallback)\n      return () => keypressListeners.delete(wrappedCallback)\n    },\n\n    renderStyled(content: StyledContent): void {\n      const styledString = styledContentToString(content)\n      this.write(styledString)\n    },\n\n    getCursorPosition(): { x: number; y: number } {\n      return { ...cursorPosition }\n    },\n\n    setCursorPosition(x: number, y: number): void {\n      cursorPosition = { x: Math.max(0, x), y: Math.max(0, y) }\n    },\n\n    setCursorVisible(visible: boolean): void {\n      cursorVisible = visible\n    },\n\n    // Extended methods\n    setDimensions(dimensions: TerminalDimensions): void {\n      currentDimensions = { ...dimensions }\n      resizeListeners.forEach((listener) => listener(currentDimensions))\n    },\n\n    dispatchKeyPress(key: string, modifiers: KeyModifiers): void {\n      keypressListeners.forEach((listener) => {\n        listener({ key, modifiers })\n      })\n\n      if (inputResolve) {\n        if (key === \"Enter\") {\n          const value = inputBuffer\n          inputBuffer = \"\"\n          inputResolve(value)\n          inputResolve = null\n          inputReject = null\n        } else if (key === \"Backspace\") {\n          inputBuffer = inputBuffer.slice(0, -1)\n        } else if (key.length === 1) {\n          inputBuffer += key\n        }\n      }\n    },\n\n    getPrompt(): string {\n      return currentPrompt\n    },\n\n    isWaitingForInput(): boolean {\n      return inputResolve !== null\n    },\n\n    cancelInput(): void {\n      if (inputReject) {\n        inputReject(new Error(\"Input cancelled\"))\n        inputResolve = null\n        inputReject = null\n        inputBuffer = \"\"\n      }\n    },\n  }\n\n  return bridge\n}\n\n// Export default factory\nexport { createCLITerminalBridge as default }\n",
      "type": "registry:ui"
    }
  ]
}