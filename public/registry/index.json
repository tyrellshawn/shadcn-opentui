{
  "$schema": "https://ui.shadcn.com/schema/registry.json",
  "name": "@shadcn-opentui",
  "description": "Terminal components for shadcn/ui powered by OpenTUI",
  "homepage": "https://opentui.dev",
  "repository": "https://github.com/shadcn-opentui/terminal",
  "items": [
    {
      "name": "terminal",
      "type": "registry:ui",
      "title": "Terminal",
      "description": "A fully featured terminal emulator component with command history, autocomplete, and theming.",
      "dependencies": [
        "lucide-react",
        "tailwind-merge",
        "clsx",
        "tailwindcss-animate",
        "tailwindcss"
      ],
      "registryDependencies": [],
      "tailwind": {
        "config": {
          "theme": {
            "extend": {
              "keyframes": {
                "terminal-blink": {
                  "0%, 50%": {
                    "opacity": "1"
                  },
                  "51%, 100%": {
                    "opacity": "0"
                  }
                }
              },
              "animation": {
                "terminal-blink": "terminal-blink 1s infinite"
              }
            }
          }
        }
      },
      "css": {
        ".terminal-scrollbar::-webkit-scrollbar": {
          "width": "6px"
        },
        ".terminal-scrollbar::-webkit-scrollbar-track": {
          "background": "transparent"
        },
        ".terminal-scrollbar::-webkit-scrollbar-thumb": {
          "background": "rgba(74, 222, 128, 0.3)",
          "border-radius": "3px"
        },
        ".terminal-scrollbar::-webkit-scrollbar-thumb:hover": {
          "background": "rgba(74, 222, 128, 0.5)"
        },
        ".terminal-scrollbar": {
          "scrollbar-width": "thin",
          "scrollbar-color": "rgba(74, 222, 128, 0.3) transparent"
        }
      },
      "files": [
        {
          "path": "components/ui/terminal.tsx",
          "content": "\"use client\"\r\n\r\nimport React, { useState, useRef, useCallback, useContext, createContext, useEffect, useLayoutEffect } from \"react\"\r\nimport { cn } from \"@/lib/utils\"\r\nimport type { CommandHandler } from \"@/lib/types\" // Declare or import CommandHandler\r\n\r\ninterface TerminalLine {\r\n  id: string\r\n  type: \"input\" | \"output\" | \"error\" | \"success\"\r\n  content: string\r\n  timestamp: Date\r\n}\r\n\r\ninterface TerminalCommand {\r\n  name: string\r\n  description: string\r\n  handler: (args: string[], context?: any) => Promise<void> | void\r\n  category?: \"system\" | \"ui\" | \"data\" | \"custom\"\r\n  requiresUI?: boolean\r\n}\r\n\r\ninterface TerminalProps extends React.HTMLAttributes<HTMLDivElement> {\r\n  prompt?: string\r\n  welcomeMessage?: string[]\r\n  commands?: Record<string, CommandHandler>\r\n  onCommand?: (command: string, args: string[]) => Promise<void> | void\r\n  maxLines?: number\r\n  showTimestamp?: boolean\r\n  variant?: \"default\" | \"compact\" | \"minimal\"\r\n  autoScroll?: boolean\r\n  smoothScroll?: boolean\r\n}\r\n\r\ninterface TerminalUIComponent {\r\n  id: string\r\n  type: \"form\" | \"menu\" | \"slider\" | \"progress\" | \"table\" | \"chart\"\r\n  props: Record<string, any>\r\n  active: boolean\r\n}\r\n\r\ninterface TerminalState {\r\n  mode: \"command\" | \"ui\" | \"form\"\r\n  activeComponent?: TerminalUIComponent\r\n  formData: Record<string, any>\r\n  menuSelection: number\r\n}\r\n\r\n  interface OpenTUIContext {\n    state: TerminalState\n    setState: React.Dispatch<React.SetStateAction<TerminalState>>\n    addUIComponent: (component: TerminalUIComponent) => void\n    removeUIComponent: (id: string) => void\n    updateFormData: (key: string, value: any) => void\n    addLine: (content: string, type?: TerminalLine[\"type\"]) => void\n    clearLines: () => void\n    updateLastLine: (content: string, type?: TerminalLine[\"type\"]) => void\n  }\n\r\nconst OpenTUIContext = createContext<OpenTUIContext | null>(null)\r\n\r\nexport const useOpenTUI = () => {\r\n  const context = useContext(OpenTUIContext)\r\n  if (!context) {\r\n    throw new Error(\"useOpenTUI must be used within an OpenTUI provider\")\r\n  }\r\n  return context\r\n}\r\n\r\nconst createBuiltInCommands = (\n  addLine: (content: string, type?: TerminalLine[\"type\"]) => void,\n  clearLines: () => void,\n  updateLastLine: (content: string, type?: TerminalLine[\"type\"]) => void,\n  commandHistory: string[],\n  opentuiContext?: OpenTUIContext,\n): TerminalCommand[] => [\n  {\r\n    name: \"clear\",\r\n    description: \"Clear the terminal screen\",\r\n    handler: () => clearLines(),\r\n  },\r\n  {\r\n    name: \"help\",\r\n    description: \"Show available commands\",\r\n    handler: () => {\r\n      addLine(\"Available commands:\", \"success\")\r\n      addLine(\"  clear      - Clear the terminal screen\")\r\n      addLine(\"  help       - Show this help message\")\r\n      addLine(\"  history    - Show command history\")\r\n      addLine(\"  date       - Show current date and time\")\r\n      addLine(\"  opentui    - Show OpenTUI information\")\r\n      addLine(\"  ui         - Enter UI mode for interactive components\")\r\n      addLine(\"  form       - Create an interactive form\")\r\n      addLine(\"  menu       - Create an interactive menu\")\r\n      addLine(\"  progress   - Show a progress bar\")\r\n      addLine(\"  ascii      - Generate ASCII art\")\r\n      addLine(\"  table      - Display data in table format\")\r\n    },\r\n  },\r\n  {\r\n    name: \"history\",\r\n    description: \"Show command history\",\r\n    handler: () => {\r\n      if (commandHistory.length === 0) {\r\n        addLine(\"No commands in history\")\r\n        return\r\n      }\r\n      addLine(\"Command history:\", \"success\")\r\n      commandHistory.forEach((cmd, index) => {\r\n        addLine(`  ${(index + 1).toString().padStart(3)} ${cmd}`)\r\n      })\r\n    },\r\n  },\r\n  {\r\n    name: \"date\",\r\n    description: \"Show current date and time\",\r\n    handler: () => {\r\n      addLine(new Date().toLocaleString(), \"success\")\r\n    },\r\n  },\r\n  {\r\n    name: \"opentui\",\r\n    description: \"Show OpenTUI information\",\r\n    category: \"system\",\r\n    handler: () => {\r\n      addLine(\"ðŸš€ OpenTUI Terminal Component\", \"success\")\r\n      addLine(\"Built with React and shadcn/ui\")\r\n      addLine(\"GitHub: https://github.com/sst/opentui\")\r\n      addLine(\"Type 'help' for available commands\")\r\n    },\r\n  },\r\n  {\r\n    name: \"ui\",\r\n    description: \"Enter UI mode for interactive components\",\r\n    category: \"ui\",\r\n    requiresUI: true,\r\n    handler: (args) => {\r\n      if (!opentuiContext) {\r\n        addLine(\"OpenTUI context not available\", \"error\")\r\n        return\r\n      }\r\n\r\n      const [componentType] = args\r\n      if (!componentType) {\r\n        addLine(\"Available UI components: form, menu, slider, progress\", \"success\")\r\n        addLine(\"Usage: ui <component-type>\")\r\n        return\r\n      }\r\n\r\n      opentuiContext.setState((prev) => ({\r\n        ...prev,\r\n        mode: \"ui\",\r\n        activeComponent: {\r\n          id: `ui-${Date.now()}`,\r\n          type: componentType as any,\r\n          props: {},\r\n          active: true,\r\n        },\r\n      }))\r\n\r\n      addLine(`Entering ${componentType} UI mode...`, \"success\")\r\n      addLine(\"Press ESC to return to command mode\")\r\n    },\r\n  },\r\n  {\r\n    name: \"form\",\r\n    description: \"Create an interactive form\",\r\n    category: \"ui\",\r\n    requiresUI: true,\r\n    handler: (args) => {\r\n      if (!opentuiContext) {\r\n        addLine(\"OpenTUI context not available\", \"error\")\r\n        return\r\n      }\r\n\r\n      const formFields = args.length > 0 ? args : [\"name\", \"email\"]\r\n\r\n      opentuiContext.setState((prev) => ({\r\n        ...prev,\r\n        mode: \"form\",\r\n        activeComponent: {\r\n          id: `form-${Date.now()}`,\r\n          type: \"form\",\r\n          props: { fields: formFields },\r\n          active: true,\r\n        },\r\n      }))\r\n\r\n      addLine(`Creating form with fields: ${formFields.join(\", \")}`, \"success\")\r\n      addLine(\"Use TAB to navigate, ENTER to submit, ESC to cancel\")\r\n    },\r\n  },\r\n  {\r\n    name: \"menu\",\r\n    description: \"Create an interactive menu\",\r\n    category: \"ui\",\r\n    requiresUI: true,\r\n    handler: (args) => {\r\n      if (!opentuiContext) {\r\n        addLine(\"OpenTUI context not available\", \"error\")\r\n        return\r\n      }\r\n\r\n      const menuItems = args.length > 0 ? args : [\"Option 1\", \"Option 2\", \"Option 3\"]\r\n\r\n      opentuiContext.setState((prev) => ({\r\n        ...prev,\r\n        mode: \"ui\",\r\n        activeComponent: {\r\n          id: `menu-${Date.now()}`,\r\n          type: \"menu\",\r\n          props: { items: menuItems },\r\n          active: true,\r\n        },\r\n        menuSelection: 0,\r\n      }))\r\n\r\n      addLine(`Creating menu with options: ${menuItems.join(\", \")}`, \"success\")\r\n      addLine(\"Use â†‘â†“ arrows to navigate, ENTER to select, ESC to cancel\")\r\n    },\r\n  },\r\n  {\n    name: \"progress\",\n    description: \"Show a progress bar\",\n    category: \"ui\",\n    handler: async (args) => {\n      const duration = Number.parseInt(args[0]) || 3000\n      const steps = 20\n      const stepDuration = duration / steps\n\n      addLine(\"Starting progress...\")\n\n      // Add the initial progress line\n      addLine(`Progress: [â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 0%`)\n\n      for (let i = 1; i <= steps; i++) {\n        const percent = Math.round((i / steps) * 100)\n        const filled = \"â–ˆ\".repeat(i)\n        const empty = \"â–‘\".repeat(steps - i)\n        const bar = `[${filled}${empty}] ${percent}%`\n\n        // Always update the last line - never add a new one\n        updateLastLine(`Progress: ${bar}`)\n\n        if (i < steps) {\n          await new Promise((resolve) => setTimeout(resolve, stepDuration))\n        }\n      }\n\n      addLine(\"Progress complete!\", \"success\")\n    },\n  },\n  {\r\n    name: \"ascii\",\r\n    description: \"Generate ASCII art\",\r\n    category: \"ui\",\r\n    handler: (args) => {\r\n      const text = args.join(\" \") || \"OpenTUI\"\r\n      addLine(\"Generating ASCII art...\", \"success\")\r\n\r\n      // Simple ASCII art generator\r\n      const asciiArt = [\r\n        \"  ___                   _____ _   _ ___ \",\r\n        \" / _ \\\\ _ __   ___ _ __  |_   _| | | |_ _|\",\r\n        \"| | | | '_ \\\\ / _ \\\\ '_ \\\\   | | | | | || | \",\r\n        \"| |_| | |_) |  __/ | | |  | | | |_| || | \",\r\n        \" \\\\___/| .__/ \\\\___|_| |_|  |_|  \\\\___/|___|\",\r\n        \"      |_|                               \",\r\n      ]\r\n\r\n      asciiArt.forEach((line) => addLine(line, \"success\"))\r\n    },\r\n  },\r\n  {\r\n    name: \"table\",\r\n    description: \"Display data in table format\",\r\n    category: \"data\",\r\n    handler: (args) => {\r\n      const sampleData = [\r\n        [\"Name\", \"Age\", \"City\"],\r\n        [\"Alice\", \"25\", \"New York\"],\r\n        [\"Bob\", \"30\", \"San Francisco\"],\r\n        [\"Charlie\", \"35\", \"Chicago\"],\r\n      ]\r\n\r\n      addLine(\"Sample Data Table:\", \"success\")\r\n      sampleData.forEach((row, index) => {\r\n        const formattedRow = row.map((cell) => cell.padEnd(12)).join(\" | \")\r\n        addLine(index === 0 ? `| ${formattedRow} |` : `| ${formattedRow} |`, \"output\")\r\n        if (index === 0) {\r\n          addLine(`|${\"-\".repeat(formattedRow.length + 2)}|`, \"output\")\r\n        }\r\n      })\r\n    },\r\n  },\r\n]\r\n\r\nconst Terminal = React.forwardRef<HTMLDivElement, TerminalProps>(\r\n  (\r\n    {\r\n      className,\r\n      prompt = \"$\",\r\n      welcomeMessage = [\"Welcome to OpenTUI Terminal\", 'Type \"help\" to see available commands'],\r\n      commands = {},\r\n      onCommand,\r\n      maxLines = 1000,\r\n      showTimestamp = false,\r\n      variant = \"default\",\r\n      autoScroll = true,\r\n      smoothScroll = true,\r\n      ...props\r\n    },\r\n    ref,\r\n  ) => {\r\n    const [lines, setLines] = useState<TerminalLine[]>(() =>\r\n      welcomeMessage.map((msg, i) => ({\r\n        id: `welcome-${i}`,\r\n        type: \"output\" as const,\r\n        content: msg,\r\n        timestamp: new Date(),\r\n      })),\r\n    )\r\n\r\n    const [currentInput, setCurrentInput] = useState(\"\")\r\n    const [isProcessing, setIsProcessing] = useState(false)\r\n    const [commandHistory, setCommandHistory] = useState<string[]>([])\r\n    const [historyIndex, setHistoryIndex] = useState(-1)\r\n    const [cursorPosition, setCursorPosition] = useState(0)\r\n    const [userScrolledUp, setUserScrolledUp] = useState(false)\r\n\r\n    const inputRef = useRef<HTMLInputElement>(null)\r\n    const terminalRef = useRef<HTMLDivElement>(null)\r\n    const lineIdCounter = useRef(0)\r\n    const scrollAnimationRef = useRef<number | null>(null)\r\n    const lastScrollTimeRef = useRef<number>(0)\r\n    const rapidUpdateCountRef = useRef<number>(0)\r\n    const updateTimestampsRef = useRef<number[]>([])\r\n    const pendingScrollRef = useRef<number | null>(null)\r\n    const velocityRef = useRef<number>(0)\r\n    const isAnimatingRef = useRef<boolean>(false)\r\n    const targetScrollRef = useRef<number>(0)\r\n\r\n    const opentuiState = useState<TerminalState>({\n      mode: \"command\",\n      formData: {},\n      menuSelection: 0,\n    })\n\n    const [currentFormFieldIndex, setCurrentFormFieldIndex] = useState(0)\n    const formInputRefs = useRef<(HTMLInputElement | null)[]>([])\n\n    const addLine = useCallback(\n      (content: string, type: TerminalLine[\"type\"] = \"output\") => {\n        const newLine: TerminalLine = {\n          id: `line-${lineIdCounter.current++}`,\n          type,\n          content,\n          timestamp: new Date(),\n        }\n\n        setLines((prev) => {\n          const newLines = [...prev, newLine]\n          return newLines.length > maxLines ? newLines.slice(-maxLines) : newLines\n        })\n      },\n      [maxLines],\n    )\n\n    const updateLastLine = useCallback(\n      (content: string, type?: TerminalLine[\"type\"]) => {\n        setLines((prev) => {\n          if (prev.length === 0) return prev\n          const newLines = [...prev]\n          const lastLine = newLines[newLines.length - 1]\n          newLines[newLines.length - 1] = {\n            ...lastLine,\n            content,\n            type: type || lastLine.type,\n            timestamp: new Date(),\n          }\n          return newLines\n        })\n      },\n      [],\n    )\n\n    const clearLines = useCallback(() => {\n      setLines([])\n    }, [])\n\n    const opentuiContext: OpenTUIContext = {\n      state: opentuiState[0],\n      setState: opentuiState[1],\n      addUIComponent: (component) => {\n        opentuiState[1]((prev) => ({\n          ...prev,\n          activeComponent: component,\n        }))\n      },\n      removeUIComponent: (id) => {\n        opentuiState[1]((prev) => ({\n          ...prev,\n          activeComponent: prev.activeComponent?.id === id ? undefined : prev.activeComponent,\n        }))\n      },\n      updateFormData: (key, value) => {\n        opentuiState[1]((prev) => ({\n          ...prev,\n          formData: { ...prev.formData, [key]: value },\n        }))\n      },\n      addLine,\n      clearLines,\n      updateLastLine,\n    }\n\r\n    const builtInCommands = createBuiltInCommands(addLine, clearLines, updateLastLine, commandHistory, opentuiContext)\r\n    const allCommands = [...builtInCommands, ...Object.values(commands)]\r\n\r\n    const processCommand = useCallback(\r\n      async (input: string) => {\r\n        const [commandName, ...args] = input.trim().split(/\\s+/)\r\n        const command = allCommands.find((cmd) => cmd.name === commandName)\r\n\r\n        if (command) {\r\n          try {\r\n            await command.handler(args, opentuiContext)\r\n          } catch (error) {\r\n            addLine(\r\n              `Error executing ${commandName}: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n              \"error\",\r\n            )\r\n          }\r\n        } else if (onCommand) {\r\n          try {\r\n            await onCommand(input, args)\r\n          } catch (error) {\r\n            addLine(`Error: ${error instanceof Error ? error.message : \"Unknown error\"}`, \"error\")\r\n          }\r\n        } else {\r\n          addLine(`Command not found: ${commandName}`, \"error\")\r\n          addLine(\"Type 'help' for available commands\")\r\n        }\r\n      },\r\n      [onCommand, addLine],\r\n    )\r\n\r\n    const handleCommand = async (command: string) => {\r\n      if (!command.trim()) return\r\n\r\n      setCommandHistory((prev) => [...prev, command])\r\n      setHistoryIndex(-1)\r\n\r\n      const inputLine = showTimestamp\r\n        ? `[${new Date().toLocaleTimeString()}] ${prompt} ${command}`\r\n        : `${prompt} ${command}`\r\n\r\n      addLine(inputLine, \"input\")\r\n      setCurrentInput(\"\")\r\n      setIsProcessing(true)\r\n\r\n      try {\r\n        await processCommand(command)\r\n      } finally {\r\n        setIsProcessing(false)\r\n        setTimeout(() => {\r\n          inputRef.current?.focus()\r\n        }, 0)\r\n      }\r\n    }\r\n\r\n    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n      if (opentuiState[0].mode === \"ui\" && opentuiState[0].activeComponent?.type === \"menu\") {\n        if (e.key === \"ArrowUp\") {\n          e.preventDefault()\n          opentuiState[1]((prev) => ({\n            ...prev,\n            menuSelection: Math.max(0, prev.menuSelection - 1),\n          }))\n          return\n        } else if (e.key === \"ArrowDown\") {\n          e.preventDefault()\n          const maxItems = opentuiState[0].activeComponent?.props.items?.length || 0\n          opentuiState[1]((prev) => ({\n            ...prev,\n            menuSelection: Math.min(maxItems - 1, prev.menuSelection + 1),\n          }))\n          return\n        } else if (e.key === \"Enter\") {\n          e.preventDefault()\n          const selectedItem = opentuiState[0].activeComponent?.props.items?.[opentuiState[0].menuSelection]\n          if (selectedItem) {\n            addLine(`Selected: ${selectedItem}`, \"success\")\n            opentuiState[1]((prev) => ({ ...prev, mode: \"command\", activeComponent: undefined }))\n          }\n          return\n        }\n      }\n\n      if (e.key === \"Escape\" && opentuiState[0].mode !== \"command\") {\n        e.preventDefault()\n        opentuiState[1]((prev) => ({ ...prev, mode: \"command\", activeComponent: undefined, formData: {} }))\n        setCurrentFormFieldIndex(0)\n        addLine(\"Exited UI mode\", \"success\")\n        return\n      }\n\r\n      setTimeout(() => {\r\n        if (inputRef.current) {\r\n          setCursorPosition(inputRef.current.selectionStart || 0)\r\n        }\r\n      }, 0)\r\n\r\n      if (e.key === \"Enter\") {\r\n        e.preventDefault()\r\n        handleCommand(currentInput)\r\n      } else if (e.key === \"ArrowUp\") {\r\n        e.preventDefault()\r\n        if (commandHistory.length > 0) {\r\n          const newIndex = historyIndex === -1 ? commandHistory.length - 1 : Math.max(0, historyIndex - 1)\r\n          setHistoryIndex(newIndex)\r\n          setCurrentInput(commandHistory[newIndex])\r\n        }\r\n      } else if (e.key === \"ArrowDown\") {\r\n        e.preventDefault()\r\n        if (historyIndex !== -1) {\r\n          const newIndex = historyIndex + 1\r\n          if (newIndex >= commandHistory.length) {\r\n            setHistoryIndex(-1)\r\n            setCurrentInput(\"\")\r\n          } else {\r\n            setHistoryIndex(newIndex)\r\n            setCurrentInput(commandHistory[newIndex])\r\n          }\r\n        }\r\n      } else if (e.key === \"Tab\") {\r\n        e.preventDefault()\r\n        const commandNames = allCommands.map((cmd) => cmd.name)\r\n        const matches = commandNames.filter((cmd) => cmd.startsWith(currentInput))\r\n\r\n        if (matches.length === 1) {\r\n          setCurrentInput(matches[0])\r\n        } else if (matches.length > 1) {\r\n          addLine(`Available completions: ${matches.join(\", \")}`, \"success\")\r\n        }\r\n      } else if (e.key === \"l\" && e.ctrlKey) {\r\n        e.preventDefault()\r\n        clearLines()\r\n      }\r\n    }\r\n\r\n    const handleFormKeyDown = (e: React.KeyboardEvent<HTMLInputElement>, fieldIndex: number) => {\n      const fields = opentuiState[0].activeComponent?.props.fields || []\n      \n      if (e.key === \"Enter\") {\n        e.preventDefault()\n        \n        // Collect all form data\n        const formData: Record<string, string> = {}\n        formInputRefs.current.forEach((input, idx) => {\n          if (input) {\n            formData[fields[idx]] = input.value\n          }\n        })\n        \n        // Display form submission\n        addLine(\"Form submitted:\", \"success\")\n        Object.entries(formData).forEach(([key, value]) => {\n          addLine(`  ${key}: ${value}`)\n        })\n        \n        // Reset form and return to command mode\n        opentuiState[1]((prev) => ({ \n          ...prev, \n          mode: \"command\", \n          activeComponent: undefined,\n          formData: {} \n        }))\n        setCurrentFormFieldIndex(0)\n        formInputRefs.current = []\n        \n        // Focus back on command input\n        setTimeout(() => {\n          inputRef.current?.focus()\n        }, 0)\n        \n        return\n      }\n      \n      if (e.key === \"Tab\") {\n        e.preventDefault()\n        const nextIndex = e.shiftKey \n          ? Math.max(0, fieldIndex - 1)\n          : Math.min(fields.length - 1, fieldIndex + 1)\n        setCurrentFormFieldIndex(nextIndex)\n        formInputRefs.current[nextIndex]?.focus()\n        return\n      }\n      \n      if (e.key === \"Escape\") {\n        e.preventDefault()\n        opentuiState[1]((prev) => ({ \n          ...prev, \n          mode: \"command\", \n          activeComponent: undefined,\n          formData: {} \n        }))\n        setCurrentFormFieldIndex(0)\n        formInputRefs.current = []\n        addLine(\"Form cancelled\", \"error\")\n        setTimeout(() => {\n          inputRef.current?.focus()\n        }, 0)\n        return\n      }\n    }\n\n    const renderUIComponent = () => {\n      if (!opentuiState[0].activeComponent) return null\n\n      const { type, props } = opentuiState[0].activeComponent\n\n      switch (type) {\n        case \"menu\":\n          return (\n            <div className=\"border border-green-400/20 rounded p-2 mb-2 bg-black/50\">\n              <div className=\"text-green-400 text-xs mb-2\">MENU (Use â†‘â†“ arrows, ENTER to select)</div>\n              {props.items?.map((item: string, index: number) => (\n                <div\n                  key={index}\n                  className={cn(\n                    \"px-2 py-1 font-mono text-sm\",\n                    index === opentuiState[0].menuSelection ? \"bg-green-400 text-black\" : \"text-green-400\",\n                  )}\n                >\n                  {index === opentuiState[0].menuSelection ? \"â–º \" : \"  \"}\n                  {item}\n                </div>\n              ))}\n            </div>\n          )\n        case \"form\":\n          return (\n            <div className=\"border border-green-400/20 rounded p-2 mb-2 bg-black/50\">\n              <div className=\"text-green-400 text-xs mb-2\">FORM (TAB to navigate, ENTER to submit, ESC to cancel)</div>\n              {props.fields?.map((field: string, index: number) => (\n                <div key={index} className=\"mb-2\">\n                  <label className=\"text-green-400 text-sm block mb-1\">{field}:</label>\n                  <input\n                    ref={(el) => {\n                      formInputRefs.current[index] = el\n                      if (index === 0 && el && opentuiState[0].mode === \"form\") {\n                        setTimeout(() => el.focus(), 50)\n                      }\n                    }}\n                    type=\"text\"\n                    className=\"w-full bg-transparent border border-green-400/20 rounded px-2 py-1 text-green-400 font-mono text-sm focus:border-green-400 outline-none\"\n                    placeholder={`Enter ${field}`}\n                    onKeyDown={(e) => handleFormKeyDown(e, index)}\n                    defaultValue={opentuiState[0].formData[field] || \"\"}\n                  />\n                </div>\n              ))}\n            </div>\n          )\n        default:\n          return null\n      }\n    }\n\r\n    const getVariantStyles = () => {\r\n      switch (variant) {\r\n        case \"compact\":\r\n          return \"p-2 text-xs\"\r\n        case \"minimal\":\r\n          return \"p-3 border-0 shadow-none\"\r\n        default:\r\n          return \"p-4 text-sm shadow-2xl shadow-green-400/10\"\r\n      }\r\n    }\r\n\r\n    const getHeightClass = () => {\r\n      switch (variant) {\r\n        case \"compact\":\r\n          return \"h-64\"\r\n        case \"minimal\":\r\n          return \"h-48\"\r\n        default:\r\n          return \"h-96\"\r\n      }\r\n    }\r\n\r\n    const scrollToBottom = useCallback(\r\n      (forceInstant = false) => {\r\n        if (!terminalRef.current || !autoScroll || userScrolledUp) return\r\n\r\n        const now = performance.now()\r\n        const element = terminalRef.current\r\n        const targetScrollTop = element.scrollHeight - element.clientHeight\r\n\r\n        // Track update timestamps for data rate calculation\r\n        updateTimestampsRef.current.push(now)\r\n        // Keep only last 10 timestamps for rate calculation\r\n        if (updateTimestampsRef.current.length > 10) {\r\n          updateTimestampsRef.current.shift()\r\n        }\r\n\r\n        // Calculate data rate (updates per second)\r\n        const timestamps = updateTimestampsRef.current\r\n        let dataRate = 0\r\n        if (timestamps.length >= 2) {\r\n          const timeSpan = timestamps[timestamps.length - 1] - timestamps[0]\r\n          dataRate = timeSpan > 0 ? (timestamps.length - 1) / (timeSpan / 1000) : 0\r\n        }\r\n\r\n        // Store target for animation\r\n        targetScrollRef.current = targetScrollTop\r\n\r\n        // Determine scroll strategy based on data rate\r\n        const isRapidUpdate = dataRate > 10 // More than 10 updates/second\r\n        const isVeryRapidUpdate = dataRate > 30 // More than 30 updates/second\r\n\r\n        // For instant scroll scenarios\r\n        if (forceInstant || !smoothScroll || isVeryRapidUpdate) {\r\n          // Cancel any pending animation\r\n          if (scrollAnimationRef.current) {\r\n            cancelAnimationFrame(scrollAnimationRef.current)\r\n            scrollAnimationRef.current = null\r\n          }\r\n          if (pendingScrollRef.current) {\r\n            clearTimeout(pendingScrollRef.current)\r\n            pendingScrollRef.current = null\r\n          }\r\n          isAnimatingRef.current = false\r\n          element.scrollTop = targetScrollTop\r\n          return\r\n        }\r\n\r\n        // For rapid updates, batch them with debounce to hide intermediary states\r\n        if (isRapidUpdate) {\r\n          if (pendingScrollRef.current) {\r\n            clearTimeout(pendingScrollRef.current)\r\n          }\r\n\r\n          // Batch updates - only animate to final position after brief pause\r\n          pendingScrollRef.current = window.setTimeout(() => {\r\n            pendingScrollRef.current = null\r\n            performSmoothScroll(element, targetScrollRef.current, dataRate)\r\n          }, 16) as unknown as number // ~1 frame delay for batching\r\n\r\n          return\r\n        }\r\n\r\n        // For normal updates, animate immediately\r\n        performSmoothScroll(element, targetScrollTop, dataRate)\r\n      },\r\n      [autoScroll, userScrolledUp, smoothScroll],\r\n    )\r\n\r\n    const performSmoothScroll = useCallback((element: HTMLDivElement, targetScrollTop: number, dataRate: number) => {\r\n      // Cancel existing animation\r\n      if (scrollAnimationRef.current) {\r\n        cancelAnimationFrame(scrollAnimationRef.current)\r\n        scrollAnimationRef.current = null\r\n      }\r\n\r\n      const currentScrollTop = element.scrollTop\r\n      const distance = targetScrollTop - currentScrollTop\r\n\r\n      // Skip animation for tiny distances\r\n      if (Math.abs(distance) < 2) {\r\n        element.scrollTop = targetScrollTop\r\n        return\r\n      }\r\n\r\n      // Adaptive duration based on data rate and distance\r\n      // Faster data rate = shorter duration for responsiveness\r\n      // Larger distance = slightly longer duration for smoothness\r\n      const baseSpeed = Math.max(0.1, 1 - dataRate / 50) // 0.1 to 1.0\r\n      const distanceFactor = Math.min(1.5, 1 + Math.abs(distance) / 500)\r\n      const duration = Math.max(50, Math.min(200, 120 * baseSpeed * distanceFactor))\r\n\r\n      const startTime = performance.now()\r\n      const startScrollTop = currentScrollTop\r\n      isAnimatingRef.current = true\r\n\r\n      // Calculate initial velocity for momentum\r\n      const initialVelocity = velocityRef.current\r\n\r\n      const animateScroll = (currentTime: number) => {\r\n        if (!isAnimatingRef.current) return\r\n\r\n        const elapsed = currentTime - startTime\r\n        const progress = Math.min(elapsed / duration, 1)\r\n\r\n        // Spring-inspired easing: fast start, smooth deceleration\r\n        // Uses critically damped spring formula approximation\r\n        const springProgress = 1 - Math.pow(1 - progress, 3) * (1 + 3 * progress)\r\n\r\n        // Add momentum influence for natural feel\r\n        const momentumFactor =\r\n          Math.max(0, 1 - progress * 2) * Math.sign(initialVelocity) * Math.min(Math.abs(initialVelocity) * 0.01, 10)\r\n\r\n        const newScrollTop = startScrollTop + distance * springProgress + momentumFactor\r\n\r\n        // Check if target changed during animation (new content added)\r\n        const currentTarget = element.scrollHeight - element.clientHeight\r\n        if (Math.abs(currentTarget - targetScrollTop) > 50) {\r\n          // Target changed significantly, update and continue\r\n          targetScrollRef.current = currentTarget\r\n          element.scrollTop = currentTarget\r\n          isAnimatingRef.current = false\r\n          scrollAnimationRef.current = null\r\n          return\r\n        }\r\n\r\n        element.scrollTop = newScrollTop\r\n\r\n        // Track velocity for momentum\r\n        velocityRef.current = (distance / duration) * (1 - progress)\r\n\r\n        if (progress < 1) {\r\n          scrollAnimationRef.current = requestAnimationFrame(animateScroll)\r\n        } else {\r\n          // Ensure we end exactly at target\r\n          element.scrollTop = targetScrollTop\r\n          isAnimatingRef.current = false\r\n          scrollAnimationRef.current = null\r\n          velocityRef.current = 0\r\n        }\r\n      }\r\n\r\n      scrollAnimationRef.current = requestAnimationFrame(animateScroll)\r\n    }, [])\r\n\r\n    useLayoutEffect(() => {\r\n      scrollToBottom()\r\n    }, [lines, scrollToBottom])\r\n\r\n    const handleScroll = useCallback(() => {\r\n      if (!terminalRef.current) return\r\n\r\n      const element = terminalRef.current\r\n      const isAtBottom = element.scrollHeight - element.scrollTop - element.clientHeight < 50\r\n\r\n      setUserScrolledUp(!isAtBottom)\r\n    }, [])\r\n\r\n    const handleSubmit = useCallback(async () => {\r\n      if (!currentInput.trim() || isProcessing) return\r\n\r\n      setUserScrolledUp(false)\r\n\r\n      const input = currentInput.trim()\r\n      setCurrentInput(\"\")\r\n      setIsProcessing(true)\r\n\r\n      addLine(`${prompt} ${input}`, \"input\")\r\n\r\n      setCommandHistory((prev) => {\r\n        const newHistory = [...prev, input]\r\n        return newHistory.slice(-100)\r\n      })\r\n      setHistoryIndex(-1)\r\n\r\n      await processCommand(input)\r\n      setIsProcessing(false)\r\n    }, [currentInput, isProcessing, prompt, addLine, processCommand])\r\n\r\n    useEffect(() => {\r\n      return () => {\r\n        if (scrollAnimationRef.current) {\r\n          cancelAnimationFrame(scrollAnimationRef.current)\r\n        }\r\n        if (pendingScrollRef.current) {\r\n          clearTimeout(pendingScrollRef.current)\r\n        }\r\n      }\r\n    }, [])\r\n\r\n    return (\r\n      <OpenTUIContext.Provider value={opentuiContext}>\r\n        <div\r\n          ref={ref}\r\n          className={cn(\r\n            \"bg-black text-green-400 font-mono rounded-lg border border-border overflow-hidden\",\r\n            getVariantStyles(),\r\n            className,\r\n          )}\r\n          onClick={(e) => {\r\n            const target = e.target as HTMLElement\r\n            const isFormInput =\r\n              target.tagName === \"INPUT\" ||\r\n              target.tagName === \"TEXTAREA\" ||\r\n              target.tagName === \"SELECT\" ||\r\n              target.closest(\"input, textarea, select\")\r\n\r\n            if (isFormInput) {\r\n              return\r\n            }\r\n\r\n            if (inputRef.current && !isProcessing && opentuiState[0].mode === \"command\") {\r\n              inputRef.current.focus()\r\n            }\r\n          }}\r\n          {...props}\r\n        >\r\n          {variant !== \"minimal\" && (\r\n            <div className=\"flex items-center justify-between mb-2 pb-2 border-b border-green-400/20\">\r\n              <div className=\"text-green-400 text-xs font-semibold\">\r\n                OpenTUI Terminal {opentuiState[0].mode !== \"command\" && `- ${opentuiState[0].mode.toUpperCase()} MODE`}\r\n              </div>\r\n              <div className=\"text-green-400/60 text-xs\">Ctrl+L to clear</div>\r\n            </div>\r\n          )}\r\n\r\n          <div\r\n            ref={terminalRef}\r\n            className={cn(\"overflow-y-auto terminal-scrollbar\", getHeightClass())}\r\n            onScroll={handleScroll}\r\n            onClick={(e) => {\r\n              const target = e.target as HTMLElement\r\n              const isFormInput =\r\n                target.tagName === \"INPUT\" ||\r\n                target.tagName === \"TEXTAREA\" ||\r\n                target.tagName === \"SELECT\" ||\r\n                target.closest(\"input, textarea, select\")\r\n\r\n              if (isFormInput) {\r\n                e.stopPropagation()\r\n                return\r\n              }\r\n\r\n              e.stopPropagation()\r\n              if (inputRef.current && !isProcessing && opentuiState[0].mode === \"command\") {\r\n                inputRef.current.focus()\r\n              }\r\n            }}\r\n          >\r\n            {lines.map((line) => {\n              const isProgressLine = line.content.includes(\"Progress:\") && line.content.includes(\"[\")\n              return (\n                <div\n                  key={line.id}\n                  data-contains-progress={isProgressLine}\n                  className={cn(\n                    \"terminal-line leading-relaxed mb-1\",\n                    isProgressLine && \"font-variant-numeric-tabular\",\n                    line.type === \"input\" && \"text-white font-semibold\",\n                    line.type === \"error\" && \"text-red-400\",\n                    line.type === \"success\" && \"text-emerald-400\",\n                    line.type === \"output\" && \"text-green-400\",\n                  )}\n                >\n                  {line.content}\n                </div>\n              )\n            })}\n\r\n            {renderUIComponent()}\r\n\r\n            <div className=\"flex items-center text-white mt-1 relative\">\r\n              <span className=\"text-green-400 mr-2 font-bold shrink-0\">{prompt}</span>\r\n              <div className=\"flex-1 relative\">\r\n                <input\r\n                  ref={inputRef}\r\n                  type=\"text\"\r\n                  value={currentInput}\r\n                  onChange={(e) => {\r\n                    setCurrentInput(e.target.value)\r\n                    setCursorPosition(e.target.selectionStart || 0)\r\n                  }}\r\n                  onKeyDown={handleKeyDown}\r\n                  onSelect={() => {\r\n                    if (inputRef.current) {\r\n                      setCursorPosition(inputRef.current.selectionStart || 0)\r\n                    }\r\n                  }}\r\n                  onClick={() => {\r\n                    if (inputRef.current) {\r\n                      setCursorPosition(inputRef.current.selectionStart || 0)\r\n                    }\r\n                  }}\r\n                  disabled={isProcessing}\r\n                  className=\"w-full bg-transparent border-none outline-none text-white font-mono caret-transparent\"\r\n                  autoComplete=\"off\"\r\n                  spellCheck={false}\r\n                  placeholder={\r\n                    isProcessing\r\n                      ? \"Processing...\"\r\n                      : opentuiState[0].mode !== \"command\"\r\n                        ? `${opentuiState[0].mode.toUpperCase()} mode - ESC to exit`\r\n                        : \"Type a command...\"\r\n                  }\r\n                />\r\n                <div\n                  className=\"absolute top-0 w-2 h-5 bg-green-400 pointer-events-none animate-terminal-blink\"\n                  style={{\n                    left: `${cursorPosition * 0.6}em`,\n                  }}\n                />\n              </div>\n              {isProcessing && <span className=\"ml-2 text-yellow-400 animate-pulse\">âš¡</span>}\n            </div>\n          </div>\n        </div>\n      </OpenTUIContext.Provider>\n    )\n  },\n)\n\r\nTerminal.displayName = \"Terminal\"\r\n\r\nexport { Terminal }\r\nexport type { TerminalProps, TerminalLine, TerminalCommand, OpenTUIContext }\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "terminal-controls",
      "type": "registry:ui",
      "title": "Terminal Controls",
      "description": "Window control buttons (close, minimize, maximize) for the terminal.",
      "dependencies": [
        "class-variance-authority",
        "tailwind-merge",
        "clsx"
      ],
      "registryDependencies": [
        "terminal"
      ],
      "files": [
        {
          "path": "components/ui/terminal-controls.tsx",
          "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { TerminalSlider } from \"./terminal-slider\"\nimport { Button } from \"./button\"\nimport { cn } from \"@/lib/utils\"\n\ninterface TerminalControlsProps {\n  className?: string\n  onCommand?: (command: string) => void\n}\n\nfunction TerminalControls({ className, onCommand }: TerminalControlsProps) {\n  const [volume, setVolume] = React.useState([75])\n  const [brightness, setBrightness] = React.useState([50])\n  const [speed, setSpeed] = React.useState([25])\n\n  const handleControlCommand = (type: string, value: number) => {\n    const command = `set ${type} ${value}`\n    onCommand?.(command)\n  }\n\n  return (\n    <div className={cn(\"space-y-4 p-4 border border-green-400/20 rounded bg-black/50\", className)}>\n      <div className=\"text-green-400 font-mono text-sm border-b border-green-400/20 pb-2\">TERMINAL CONTROLS</div>\n\n      <TerminalSlider\n        label=\"Volume\"\n        value={volume}\n        onValueChange={(val) => {\n          setVolume(val)\n          handleControlCommand(\"volume\", val[0])\n        }}\n        unit=\"%\"\n        max={100}\n      />\n\n      <TerminalSlider\n        label=\"Brightness\"\n        value={brightness}\n        onValueChange={(val) => {\n          setBrightness(val)\n          handleControlCommand(\"brightness\", val[0])\n        }}\n        unit=\"%\"\n        max={100}\n        ascii\n        width={15}\n      />\n\n      <TerminalSlider\n        label=\"Processing Speed\"\n        value={speed}\n        onValueChange={(val) => {\n          setSpeed(val)\n          handleControlCommand(\"speed\", val[0])\n        }}\n        unit=\" ops/s\"\n        max={100}\n      />\n\n      <div className=\"flex gap-2 pt-2\">\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          className=\"font-mono text-xs border-green-400/20 text-green-400 hover:bg-green-400/10 bg-transparent\"\n          onClick={() => onCommand?.(\"reset controls\")}\n        >\n          RESET\n        </Button>\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          className=\"font-mono text-xs border-green-400/20 text-green-400 hover:bg-green-400/10 bg-transparent\"\n          onClick={() => onCommand?.(\"save config\")}\n        >\n          SAVE\n        </Button>\n      </div>\n    </div>\n  )\n}\n\nexport { TerminalControls }\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "terminal-slider",
      "type": "registry:ui",
      "title": "Terminal Slider",
      "description": "An ASCII slider component for terminal interfaces.",
      "dependencies": [
        "@radix-ui/react-slider",
        "tailwind-merge",
        "clsx"
      ],
      "registryDependencies": [
        "terminal"
      ],
      "files": [
        {
          "path": "components/ui/terminal-slider.tsx",
          "content": "\"use client\"\n\nimport * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\nimport { cn } from \"@/lib/utils\"\n\ninterface TerminalSliderProps extends React.ComponentProps<typeof SliderPrimitive.Root> {\n  label?: string\n  showValue?: boolean\n  unit?: string\n  ascii?: boolean\n  width?: number\n}\n\nfunction TerminalSlider({\n  className,\n  label,\n  showValue = true,\n  unit = \"\",\n  ascii = false,\n  width = 20,\n  value,\n  defaultValue,\n  min = 0,\n  max = 100,\n  ...props\n}: TerminalSliderProps) {\n  const [internalValue, setInternalValue] = React.useState(value || defaultValue || [min])\n\n  const currentValue = value || internalValue\n  const displayValue = Array.isArray(currentValue) ? currentValue[0] : currentValue\n\n  const createAsciiBar = (val: number, total: number, barWidth: number) => {\n    const filled = Math.round((val / total) * barWidth)\n    const empty = barWidth - filled\n    return \"â–ˆ\".repeat(filled) + \"â–‘\".repeat(empty)\n  }\n\n  const handleValueChange = (newValue: number[]) => {\n    setInternalValue(newValue)\n    props.onValueChange?.(newValue)\n  }\n\n  return (\n    <div className={cn(\"space-y-2 font-mono\", className)}>\n      {label && (\n        <div className=\"flex items-center justify-between text-sm\">\n          <span className=\"text-green-400\">{label}</span>\n          {showValue && (\n            <span className=\"text-muted-foreground\">\n              {displayValue}\n              {unit}\n            </span>\n          )}\n        </div>\n      )}\n\n      {ascii ? (\n        <div className=\"space-y-1\">\n          <div className=\"text-xs text-green-400 font-mono\">\n            [{createAsciiBar(displayValue, max, width)}] {displayValue}\n            {unit}\n          </div>\n          <SliderPrimitive.Root\n            value={currentValue}\n            defaultValue={defaultValue}\n            min={min}\n            max={max}\n            onValueChange={handleValueChange}\n            className=\"relative flex w-full touch-none items-center select-none opacity-0 absolute inset-0\"\n            {...props}\n          >\n            <SliderPrimitive.Track className=\"bg-transparent relative grow overflow-hidden h-4 w-full\">\n              <SliderPrimitive.Range className=\"bg-transparent absolute h-full\" />\n            </SliderPrimitive.Track>\n            <SliderPrimitive.Thumb className=\"bg-transparent border-transparent block size-4 shrink-0\" />\n          </SliderPrimitive.Root>\n        </div>\n      ) : (\n        <SliderPrimitive.Root\n          value={currentValue}\n          defaultValue={defaultValue}\n          min={min}\n          max={max}\n          onValueChange={handleValueChange}\n          className={cn(\"relative flex w-full touch-none items-center select-none\", \"data-[disabled]:opacity-50\")}\n          {...props}\n        >\n          <SliderPrimitive.Track className=\"bg-muted/30 border border-green-400/20 relative grow overflow-hidden rounded-none h-2 w-full\">\n            <SliderPrimitive.Range className=\"bg-green-400 absolute h-full\" />\n          </SliderPrimitive.Track>\n          <SliderPrimitive.Thumb className=\"border-green-400 bg-green-400 ring-green-400/50 block size-3 shrink-0 rounded-none border shadow-sm transition-[color,box-shadow] hover:ring-2 focus-visible:ring-2 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50\" />\n        </SliderPrimitive.Root>\n      )}\n\n      <div className=\"flex justify-between text-xs text-muted-foreground font-mono\">\n        <span>\n          {min}\n          {unit}\n        </span>\n        <span>\n          {max}\n          {unit}\n        </span>\n      </div>\n    </div>\n  )\n}\n\nexport { TerminalSlider }\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "cli-plugin-types",
      "type": "registry:lib",
      "title": "CLI Plugin Types",
      "description": "Type definitions for the CLI plugin framework supporting Ink v6.6.0+ and Pastel v4.0.0+.",
      "dependencies": [],
      "registryDependencies": [],
      "files": [
        {
          "path": "lib/opentui/plugins/cli/types.ts",
          "content": "// OpenTUI CLI Plugin Framework Types\n// Library-agnostic plugin system supporting Ink v6.6.0+, Pastel v4.0.0+, and future CLI libraries\n\nimport type { OpenTUIRuntimeContext, TerminalLine } from \"../../types\"\n\n// ============================================\n// Version Management\n// ============================================\n\n/** Supported CLI library identifiers */\nexport type CLILibrary = \"ink\" | \"pastel\" | \"custom\"\n\n/** Semantic version range (e.g., \"6.6.0\", \">=6.6.0 <7.0.0\") */\nexport type VersionRange = string\n\n/** Version compatibility result */\nexport interface VersionCompatibility {\n  compatible: boolean\n  negotiatedVersion: string\n  warnings?: string[]\n  requiredShims?: string[]\n  missingFeatures?: CLIFeature[]\n}\n\n/** Feature availability by version */\nexport interface VersionFeatureMap {\n  version: string\n  features: CLIFeature[]\n}\n\n// ============================================\n// Plugin Manifest\n// ============================================\n\n/** Declares plugin metadata and requirements */\nexport interface CLIAppManifest {\n  /** Unique plugin identifier */\n  name: string\n  /** Plugin version (semver) */\n  version: string\n  /** Human-readable description */\n  description?: string\n  /** Author information */\n  author?: string\n  /** Repository URL */\n  repository?: string\n  /** Target CLI library */\n  library: CLILibrary\n  /** Required library version (semver range) */\n  libraryVersion: VersionRange\n  /** Plugin capabilities/permissions */\n  capabilities?: CLIAppCapabilities\n  /** Entry command to trigger this app */\n  entryCommand?: string\n  /** Keywords for discoverability */\n  keywords?: string[]\n  /** License */\n  license?: string\n}\n\n/** Capabilities the CLI app requires */\nexport interface CLIAppCapabilities {\n  /** Needs keyboard input handling */\n  stdin?: boolean\n  /** Takes over the terminal (full-screen mode) */\n  fullscreen?: boolean\n  /** Maintains state between invocations */\n  persistentState?: boolean\n  /** Requires network access */\n  networking?: boolean\n  /** Requires file system access */\n  fileSystem?: boolean\n  /** Custom rendering (bypasses default renderer) */\n  customRenderer?: boolean\n  /** Requires focus management */\n  focusManagement?: boolean\n}\n\n// ============================================\n// CLI Application Definition\n// ============================================\n\n/** Complete CLI application definition */\nexport interface CLIAppDefinition<TProps = Record<string, unknown>> {\n  /** Plugin manifest */\n  manifest: CLIAppManifest\n  /** The main React component */\n  Component: React.ComponentType<TProps & CLIAppContext>\n  /** Commands this app provides */\n  commands?: CLICommand[]\n  /** Lifecycle hooks */\n  lifecycle?: CLIAppLifecycle\n}\n\n/** Lifecycle hooks for CLI apps */\nexport interface CLIAppLifecycle {\n  /** Called when app is registered */\n  onRegister?: (registry: CLIAppRegistry) => void\n  /** Called before app starts */\n  onBeforeStart?: (context: CLIAppContext) => void | Promise<void>\n  /** Called when app exits */\n  onExit?: (code: number) => void\n  /** Called when app encounters an error */\n  onError?: (error: Error) => void\n  /** Called when app is suspended */\n  onSuspend?: () => void\n  /** Called when app is resumed */\n  onResume?: () => void\n}\n\n// ============================================\n// Runtime Context\n// ============================================\n\n/** Context provided to running CLI apps */\nexport interface CLIAppContext {\n  /** Terminal bridge for I/O */\n  terminal: CLITerminalBridge\n  /** OpenTUI runtime reference */\n  runtime: OpenTUIRuntimeContext\n  /** Exit the application */\n  exit: (code?: number) => void\n  /** Command line arguments */\n  args: string[]\n  /** Parsed flags */\n  flags: Record<string, string | boolean | number>\n  /** App instance ID */\n  instanceId: string\n  /** App manifest */\n  manifest: CLIAppManifest\n  /** Suspend the app (allow other commands) */\n  suspend: () => void\n  /** Check if app is in foreground */\n  isForeground: () => boolean\n}\n\n/** Bridge between CLI app and OpenTUI terminal */\nexport interface CLITerminalBridge {\n  /** Write raw content */\n  write: (content: string) => void\n  /** Write a line with optional type */\n  writeLine: (content: string, type?: TerminalLine[\"type\"]) => void\n  /** Clear terminal */\n  clear: () => void\n  /** Update the current (last) line - useful for progress indicators */\n  updateLine: (content: string) => void\n  /** Set the prompt text */\n  setPrompt: (prompt: string) => void\n  /** Request user input */\n  requestInput: (prompt?: string) => Promise<string>\n  /** Terminal dimensions */\n  dimensions: TerminalDimensions\n  /** Subscribe to resize events */\n  onResize: (callback: (dims: TerminalDimensions) => void) => () => void\n  /** Subscribe to keyboard events */\n  onKeyPress: (callback: (key: string, modifiers: KeyModifiers) => void) => () => void\n  /** Render styled content using ANSI codes */\n  renderStyled: (content: StyledContent) => void\n  /** Get current cursor position */\n  getCursorPosition: () => { x: number; y: number }\n  /** Set cursor position */\n  setCursorPosition: (x: number, y: number) => void\n  /** Show/hide cursor */\n  setCursorVisible: (visible: boolean) => void\n}\n\nexport interface TerminalDimensions {\n  columns: number\n  rows: number\n}\n\nexport interface KeyModifiers {\n  ctrl: boolean\n  alt: boolean\n  shift: boolean\n  meta: boolean\n}\n\n/** Styled content for terminal rendering */\nexport interface StyledContent {\n  text: string\n  bold?: boolean\n  italic?: boolean\n  underline?: boolean\n  strikethrough?: boolean\n  color?: string\n  backgroundColor?: string\n  dim?: boolean\n  inverse?: boolean\n}\n\n// ============================================\n// Command Definition\n// ============================================\n\n/** CLI command definition */\nexport interface CLICommand {\n  /** Command name */\n  name: string\n  /** Description shown in help */\n  description: string\n  /** Command aliases */\n  aliases?: string[]\n  /** Positional arguments */\n  args?: CLICommandArg[]\n  /** Flag options */\n  flags?: CLICommandFlag[]\n  /** Subcommands */\n  subcommands?: CLICommand[]\n  /** Usage examples */\n  examples?: string[]\n  /** Command handler (if not using Component) */\n  handler?: (args: string[], flags: Record<string, unknown>, ctx: CLIAppContext) => void | Promise<void>\n}\n\nexport interface CLICommandArg {\n  name: string\n  required?: boolean\n  description?: string\n  default?: string\n  /** Validation function */\n  validate?: (value: string) => boolean | string\n}\n\nexport interface CLICommandFlag {\n  name: string\n  char?: string\n  type: \"boolean\" | \"string\" | \"number\"\n  description?: string\n  default?: string | boolean | number\n  required?: boolean\n  /** Allowed values (enum-like) */\n  choices?: (string | number)[]\n}\n\n// ============================================\n// Adapter Interface\n// ============================================\n\n/** Interface all library adapters must implement */\nexport interface ICLIAdapter {\n  /** Library identifier */\n  readonly library: CLILibrary\n  /** Adapter version */\n  readonly adapterVersion: string\n  /** Supported library version range */\n  readonly supportedVersions: VersionRange\n  \n  /** Initialize the adapter */\n  initialize(): Promise<void>\n  /** Cleanup resources */\n  destroy(): Promise<void>\n  \n  /** Check version compatibility */\n  checkCompatibility(requestedVersion: string): VersionCompatibility\n  \n  /** Create a render instance for a CLI app */\n  createRenderInstance(\n    component: React.ComponentType<unknown>,\n    props: Record<string, unknown>,\n    bridge: CLITerminalBridge\n  ): CLIRenderInstance\n  \n  /** Feature support detection */\n  supportsFeature(feature: CLIFeature): boolean\n  \n  /** Get all supported features for a version */\n  getFeaturesForVersion(version: string): CLIFeature[]\n  \n  /** Apply version-specific transformations to props */\n  transformProps?(props: Record<string, unknown>, targetVersion: string): Record<string, unknown>\n}\n\n/** Running render instance */\nexport interface CLIRenderInstance {\n  /** Instance ID */\n  readonly id: string\n  /** Re-render with new props */\n  rerender(props?: Record<string, unknown>): void\n  /** Unmount the component */\n  unmount(): void\n  /** Wait for app to exit */\n  waitUntilExit(): Promise<number>\n  /** Clear rendered content */\n  clear(): void\n  /** Pause rendering */\n  pause(): void\n  /** Resume rendering */\n  resume(): void\n  /** Check if instance is active */\n  isActive(): boolean\n}\n\n/** CLI features that adapters can support */\nexport type CLIFeature = \n  | \"useInput\"\n  | \"useStdin\"\n  | \"useStdout\"\n  | \"useFocus\"\n  | \"useFocusManager\"\n  | \"measureElement\"\n  | \"staticOutput\"\n  | \"flexbox\"\n  | \"colors16\"\n  | \"colors256\"\n  | \"trueColor\"\n  | \"unicode\"\n  | \"mouse\"\n  | \"hyperlinks\"\n  | \"images\"\n  | \"boxDrawing\"\n\n// ============================================\n// Registry Types\n// ============================================\n\n/** Registry for managing CLI apps */\nexport interface CLIAppRegistry {\n  /** Register a CLI app */\n  register(app: CLIAppDefinition): void\n  /** Unregister an app */\n  unregister(name: string): void\n  /** Get an app by name */\n  get(name: string): CLIAppDefinition | undefined\n  /** List all registered apps */\n  list(): CLIAppDefinition[]\n  /** Check if app exists */\n  has(name: string): boolean\n  /** Get apps by library type */\n  getByLibrary(library: CLILibrary): CLIAppDefinition[]\n  /** Search apps by keyword */\n  search(query: string): CLIAppDefinition[]\n  /** Get app count */\n  count(): number\n}\n\n/** Registry for managing adapters */\nexport interface CLIAdapterRegistry {\n  /** Register an adapter */\n  register(adapter: ICLIAdapter): void\n  /** Unregister an adapter */\n  unregister(library: CLILibrary): void\n  /** Get adapter for library */\n  getAdapter(library: CLILibrary): ICLIAdapter | undefined\n  /** List all registered adapters */\n  list(): ICLIAdapter[]\n  /** Check library support */\n  supportsLibrary(library: CLILibrary): boolean\n  /** Get supported version range for library */\n  getSupportedVersions(library: CLILibrary): VersionRange | undefined\n}\n\n// ============================================\n// App Instance Types\n// ============================================\n\n/** Status of a running CLI app */\nexport type CLIAppStatus = \"starting\" | \"running\" | \"suspended\" | \"exiting\" | \"terminated\" | \"error\"\n\n/** Running app instance */\nexport interface CLIAppInstance {\n  /** Unique instance ID */\n  readonly id: string\n  /** App definition */\n  readonly app: CLIAppDefinition\n  /** Current status */\n  status: CLIAppStatus\n  /** Start timestamp */\n  readonly startTime: Date\n  /** Exit code (if terminated) */\n  exitCode?: number\n  /** Error (if status is error) */\n  error?: Error\n  /** Process ID (for display purposes) */\n  readonly pid: number\n  \n  /** Suspend execution (background) */\n  suspend(): void\n  /** Resume execution (foreground) */\n  resume(): void\n  /** Terminate the app */\n  terminate(code?: number): void\n  /** Send input to the app */\n  sendInput(input: string): void\n  /** Send signal to the app */\n  sendSignal(signal: CLISignal): void\n  \n  /** Subscribe to status change event */\n  onStatusChange(callback: (status: CLIAppStatus) => void): () => void\n  /** Subscribe to exit event */\n  onExit(callback: (code: number) => void): () => void\n  /** Subscribe to error event */\n  onError(callback: (error: Error) => void): () => void\n  /** Subscribe to output event */\n  onOutput(callback: (output: string) => void): () => void\n}\n\n/** Signals that can be sent to CLI apps */\nexport type CLISignal = \"SIGINT\" | \"SIGTERM\" | \"SIGKILL\" | \"SIGHUP\" | \"SIGUSR1\" | \"SIGUSR2\"\n\n// ============================================\n// Plugin Host Types\n// ============================================\n\n/** CLI Plugin Host configuration */\nexport interface CLIPluginHostOptions {\n  /** Maximum concurrent running apps */\n  maxConcurrentApps?: number\n  /** Enable sandbox mode for untrusted apps */\n  sandboxMode?: boolean\n  /** Default library if not specified */\n  defaultLibrary?: CLILibrary\n  /** Default library version if not specified */\n  defaultLibraryVersion?: VersionRange\n  /** Custom adapters to register */\n  adapters?: ICLIAdapter[]\n  /** Auto-initialize on creation */\n  autoInitialize?: boolean\n}\n\n/** CLI Plugin Host interface */\nexport interface CLIPluginHost {\n  // ============================================\n  // App Management\n  // ============================================\n  \n  /** Register a CLI app */\n  registerApp(app: CLIAppDefinition): void\n  /** Unregister an app */\n  unregisterApp(name: string): void\n  /** Get app by name */\n  getApp(name: string): CLIAppDefinition | undefined\n  /** List all apps */\n  listApps(): CLIAppDefinition[]\n  \n  // ============================================\n  // App Execution\n  // ============================================\n  \n  /** Launch an app */\n  launch(\n    name: string,\n    args?: string[],\n    flags?: Record<string, string | boolean | number>\n  ): Promise<CLIAppInstance>\n  \n  /** Get running instance */\n  getInstance(instanceId: string): CLIAppInstance | undefined\n  /** List running instances */\n  listRunningInstances(): CLIAppInstance[]\n  /** Terminate an instance */\n  terminate(instanceId: string, code?: number): void\n  /** Terminate all running apps */\n  terminateAll(): void\n  /** Get foreground instance */\n  getForegroundInstance(): CLIAppInstance | undefined\n  /** Bring instance to foreground */\n  bringToForeground(instanceId: string): void\n  \n  // ============================================\n  // Adapter Management\n  // ============================================\n  \n  /** Register an adapter */\n  registerAdapter(adapter: ICLIAdapter): void\n  /** Get adapter for library */\n  getAdapter(library: CLILibrary): ICLIAdapter | undefined\n  /** Check library support */\n  supportsLibrary(library: CLILibrary): boolean\n  /** List supported libraries */\n  listSupportedLibraries(): CLILibrary[]\n  \n  // ============================================\n  // Lifecycle\n  // ============================================\n  \n  /** Initialize the host */\n  initialize(context: OpenTUIRuntimeContext): Promise<void>\n  /** Check if host is initialized */\n  isInitialized(): boolean\n  /** Cleanup resources */\n  destroy(): Promise<void>\n  \n  // ============================================\n  // Events\n  // ============================================\n  \n  /** Subscribe to app launched event */\n  onAppLaunched(callback: (instance: CLIAppInstance) => void): () => void\n  /** Subscribe to app terminated event */\n  onAppTerminated(callback: (instance: CLIAppInstance, code: number) => void): () => void\n  /** Subscribe to app error event */\n  onAppError(callback: (instance: CLIAppInstance, error: Error) => void): () => void\n}\n\n// ============================================\n// Utility Types\n// ============================================\n\n/** Event emitter for CLI apps */\nexport interface CLIEventEmitter<T extends Record<string, unknown[]>> {\n  on<K extends keyof T>(event: K, callback: (...args: T[K]) => void): () => void\n  off<K extends keyof T>(event: K, callback: (...args: T[K]) => void): void\n  emit<K extends keyof T>(event: K, ...args: T[K]): void\n  once<K extends keyof T>(event: K, callback: (...args: T[K]) => void): () => void\n}\n\n/** Argument parser result */\nexport interface ParsedArgs {\n  args: string[]\n  flags: Record<string, string | boolean | number>\n  command?: string\n  subcommand?: string\n}\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "cli-terminal-bridge",
      "type": "registry:lib",
      "title": "CLI Terminal Bridge",
      "description": "Bridge between CLI apps and OpenTUI terminal I/O.",
      "dependencies": [],
      "registryDependencies": [
        "cli-plugin-types"
      ],
      "files": [
        {
          "path": "lib/opentui/plugins/cli/cli-terminal-bridge.ts",
          "content": "// CLI Terminal Bridge Implementation\n// Bridges CLI apps to OpenTUI terminal I/O\n\nimport type { \n  CLITerminalBridge, \n  TerminalDimensions, \n  KeyModifiers, \n  StyledContent \n} from \"./types\"\nimport type { OpenTUIRuntimeContext, TerminalLine } from \"../../types\"\n\n/** Configuration for terminal bridge */\nexport interface CLITerminalBridgeConfig {\n  /** Initial terminal dimensions */\n  initialDimensions?: TerminalDimensions\n  /** Default prompt string */\n  defaultPrompt?: string\n  /** Enable input buffering */\n  bufferInput?: boolean\n  /** Enable ANSI escape code processing */\n  processAnsiCodes?: boolean\n}\n\n/** Event types for the terminal bridge */\nexport type TerminalBridgeEventType = \"resize\" | \"keypress\" | \"input\" | \"output\"\n\n/** Event listener function */\ntype EventListener<T> = (data: T) => void\n\n/**\n * Creates a terminal bridge that connects CLI apps to OpenTUI runtime\n */\nexport function createCLITerminalBridge(\n  runtime: OpenTUIRuntimeContext,\n  config: CLITerminalBridgeConfig = {}\n): CLITerminalBridge {\n  const {\n    initialDimensions = { columns: 80, rows: 24 },\n    defaultPrompt = \"> \",\n    processAnsiCodes = true,\n  } = config\n\n  // Internal state\n  let currentDimensions = { ...initialDimensions }\n  let currentPrompt = defaultPrompt\n  let cursorPosition = { x: 0, y: 0 }\n  let cursorVisible = true\n  let inputBuffer = \"\"\n  let inputResolve: ((value: string) => void) | null = null\n\n  // Event listeners\n  const resizeListeners = new Set<EventListener<TerminalDimensions>>()\n  const keypressListeners = new Set<EventListener<{ key: string; modifiers: KeyModifiers }>>()\n\n  /**\n   * Process ANSI escape codes and convert to styled content\n   */\n  function processAnsiContent(content: string): string {\n    if (!processAnsiCodes) return content\n    \n    // Remove ANSI escape codes for now - they'll be processed by the terminal component\n    // In a full implementation, this would parse and convert to terminal-compatible styling\n    return content.replace(/\\x1b\\[[0-9;]*m/g, \"\")\n  }\n\n  /**\n   * Convert styled content to terminal-compatible string\n   */\n  function styledContentToString(content: StyledContent): string {\n    // Build ANSI escape sequence\n    const codes: number[] = []\n    \n    if (content.bold) codes.push(1)\n    if (content.dim) codes.push(2)\n    if (content.italic) codes.push(3)\n    if (content.underline) codes.push(4)\n    if (content.inverse) codes.push(7)\n    if (content.strikethrough) codes.push(9)\n    \n    // Color mapping (basic 16 colors)\n    const colorMap: Record<string, number> = {\n      black: 30, red: 31, green: 32, yellow: 33,\n      blue: 34, magenta: 35, cyan: 36, white: 37,\n      brightBlack: 90, brightRed: 91, brightGreen: 92, brightYellow: 93,\n      brightBlue: 94, brightMagenta: 95, brightCyan: 96, brightWhite: 97,\n    }\n    \n    const bgColorMap: Record<string, number> = {\n      black: 40, red: 41, green: 42, yellow: 43,\n      blue: 44, magenta: 45, cyan: 46, white: 47,\n      brightBlack: 100, brightRed: 101, brightGreen: 102, brightYellow: 103,\n      brightBlue: 104, brightMagenta: 105, brightCyan: 106, brightWhite: 107,\n    }\n    \n    if (content.color && colorMap[content.color]) {\n      codes.push(colorMap[content.color])\n    }\n    \n    if (content.backgroundColor && bgColorMap[content.backgroundColor]) {\n      codes.push(bgColorMap[content.backgroundColor])\n    }\n    \n    if (codes.length === 0) {\n      return content.text\n    }\n    \n    // Return text with ANSI codes (reset at end)\n    return `\\x1b[${codes.join(\";\")}m${content.text}\\x1b[0m`\n  }\n\n  /**\n   * Parse keyboard modifiers from event\n   */\n  function parseModifiers(event: KeyboardEvent): KeyModifiers {\n    return {\n      ctrl: event.ctrlKey,\n      alt: event.altKey,\n      shift: event.shiftKey,\n      meta: event.metaKey,\n    }\n  }\n\n  /**\n   * Handle global keypress events\n   */\n  function handleKeyPress(key: string, modifiers: KeyModifiers): void {\n    // Notify all listeners\n    keypressListeners.forEach((listener) => {\n      listener({ key, modifiers })\n    })\n\n    // Handle input if waiting for input\n    if (inputResolve) {\n      if (key === \"Enter\") {\n        const value = inputBuffer\n        inputBuffer = \"\"\n        inputResolve(value)\n        inputResolve = null\n      } else if (key === \"Backspace\") {\n        inputBuffer = inputBuffer.slice(0, -1)\n      } else if (key.length === 1) {\n        inputBuffer += key\n      }\n    }\n  }\n\n  // The bridge implementation\n  const bridge: CLITerminalBridge = {\n    write(content: string): void {\n      const processed = processAnsiContent(content)\n      // Use addLine without newline - this writes inline\n      runtime.addLine(processed, \"output\")\n    },\n\n    writeLine(content: string, type: TerminalLine[\"type\"] = \"output\"): void {\n      const processed = processAnsiContent(content)\n      runtime.addLine(processed, type)\n    },\n\n    clear(): void {\n      runtime.clearLines()\n      cursorPosition = { x: 0, y: 0 }\n    },\n\n    updateLine(content: string): void {\n      const processed = processAnsiContent(content)\n      runtime.updateLastLine(processed)\n    },\n\n    setPrompt(prompt: string): void {\n      currentPrompt = prompt\n      // Note: The actual prompt update would be handled by the terminal component\n    },\n\n    async requestInput(prompt?: string): Promise<string> {\n      if (prompt) {\n        runtime.addLine(prompt, \"output\")\n      }\n      \n      return new Promise((resolve) => {\n        inputResolve = resolve\n        inputBuffer = \"\"\n      })\n    },\n\n    get dimensions(): TerminalDimensions {\n      return { ...currentDimensions }\n    },\n\n    onResize(callback: (dims: TerminalDimensions) => void): () => void {\n      resizeListeners.add(callback)\n      return () => resizeListeners.delete(callback)\n    },\n\n    onKeyPress(callback: (key: string, modifiers: KeyModifiers) => void): () => void {\n      const wrappedCallback = ({ key, modifiers }: { key: string; modifiers: KeyModifiers }) => {\n        callback(key, modifiers)\n      }\n      keypressListeners.add(wrappedCallback)\n      return () => keypressListeners.delete(wrappedCallback)\n    },\n\n    renderStyled(content: StyledContent): void {\n      const styledString = styledContentToString(content)\n      this.write(styledString)\n    },\n\n    getCursorPosition(): { x: number; y: number } {\n      return { ...cursorPosition }\n    },\n\n    setCursorPosition(x: number, y: number): void {\n      cursorPosition = { x: Math.max(0, x), y: Math.max(0, y) }\n    },\n\n    setCursorVisible(visible: boolean): void {\n      cursorVisible = visible\n    },\n  }\n\n  return bridge\n}\n\n/**\n * Extended bridge with additional control methods\n */\nexport interface ExtendedCLITerminalBridge extends CLITerminalBridge {\n  /** Update terminal dimensions (called by resize observer) */\n  setDimensions(dimensions: TerminalDimensions): void\n  /** Dispatch a keypress event */\n  dispatchKeyPress(key: string, modifiers: KeyModifiers): void\n  /** Get current prompt */\n  getPrompt(): string\n  /** Check if currently waiting for input */\n  isWaitingForInput(): boolean\n  /** Cancel pending input request */\n  cancelInput(): void\n}\n\n/**\n * Creates an extended terminal bridge with additional control methods\n */\nexport function createExtendedCLITerminalBridge(\n  runtime: OpenTUIRuntimeContext,\n  config: CLITerminalBridgeConfig = {}\n): ExtendedCLITerminalBridge {\n  const {\n    initialDimensions = { columns: 80, rows: 24 },\n    defaultPrompt = \"> \",\n    processAnsiCodes = true,\n  } = config\n\n  // Internal state\n  let currentDimensions = { ...initialDimensions }\n  let currentPrompt = defaultPrompt\n  let cursorPosition = { x: 0, y: 0 }\n  let cursorVisible = true\n  let inputBuffer = \"\"\n  let inputResolve: ((value: string) => void) | null = null\n  let inputReject: ((reason?: unknown) => void) | null = null\n\n  // Event listeners\n  const resizeListeners = new Set<EventListener<TerminalDimensions>>()\n  const keypressListeners = new Set<EventListener<{ key: string; modifiers: KeyModifiers }>>()\n\n  function processAnsiContent(content: string): string {\n    if (!processAnsiCodes) return content\n    return content.replace(/\\x1b\\[[0-9;]*m/g, \"\")\n  }\n\n  function styledContentToString(content: StyledContent): string {\n    const codes: number[] = []\n    \n    if (content.bold) codes.push(1)\n    if (content.dim) codes.push(2)\n    if (content.italic) codes.push(3)\n    if (content.underline) codes.push(4)\n    if (content.inverse) codes.push(7)\n    if (content.strikethrough) codes.push(9)\n    \n    const colorMap: Record<string, number> = {\n      black: 30, red: 31, green: 32, yellow: 33,\n      blue: 34, magenta: 35, cyan: 36, white: 37,\n      brightBlack: 90, brightRed: 91, brightGreen: 92, brightYellow: 93,\n      brightBlue: 94, brightMagenta: 95, brightCyan: 96, brightWhite: 97,\n    }\n    \n    const bgColorMap: Record<string, number> = {\n      black: 40, red: 41, green: 42, yellow: 43,\n      blue: 44, magenta: 45, cyan: 46, white: 47,\n      brightBlack: 100, brightRed: 101, brightGreen: 102, brightYellow: 103,\n      brightBlue: 104, brightMagenta: 105, brightCyan: 106, brightWhite: 107,\n    }\n    \n    if (content.color && colorMap[content.color]) {\n      codes.push(colorMap[content.color])\n    }\n    \n    if (content.backgroundColor && bgColorMap[content.backgroundColor]) {\n      codes.push(bgColorMap[content.backgroundColor])\n    }\n    \n    if (codes.length === 0) {\n      return content.text\n    }\n    \n    return `\\x1b[${codes.join(\";\")}m${content.text}\\x1b[0m`\n  }\n\n  const bridge: ExtendedCLITerminalBridge = {\n    write(content: string): void {\n      const processed = processAnsiContent(content)\n      runtime.addLine(processed, \"output\")\n    },\n\n    writeLine(content: string, type: TerminalLine[\"type\"] = \"output\"): void {\n      const processed = processAnsiContent(content)\n      runtime.addLine(processed, type)\n    },\n\n    clear(): void {\n      runtime.clearLines()\n      cursorPosition = { x: 0, y: 0 }\n    },\n\n    updateLine(content: string): void {\n      const processed = processAnsiContent(content)\n      runtime.updateLastLine(processed)\n    },\n\n    setPrompt(prompt: string): void {\n      currentPrompt = prompt\n    },\n\n    async requestInput(prompt?: string): Promise<string> {\n      if (prompt) {\n        runtime.addLine(prompt, \"output\")\n      }\n      \n      return new Promise((resolve, reject) => {\n        inputResolve = resolve\n        inputReject = reject\n        inputBuffer = \"\"\n      })\n    },\n\n    get dimensions(): TerminalDimensions {\n      return { ...currentDimensions }\n    },\n\n    onResize(callback: (dims: TerminalDimensions) => void): () => void {\n      resizeListeners.add(callback)\n      return () => resizeListeners.delete(callback)\n    },\n\n    onKeyPress(callback: (key: string, modifiers: KeyModifiers) => void): () => void {\n      const wrappedCallback = ({ key, modifiers }: { key: string; modifiers: KeyModifiers }) => {\n        callback(key, modifiers)\n      }\n      keypressListeners.add(wrappedCallback)\n      return () => keypressListeners.delete(wrappedCallback)\n    },\n\n    renderStyled(content: StyledContent): void {\n      const styledString = styledContentToString(content)\n      this.write(styledString)\n    },\n\n    getCursorPosition(): { x: number; y: number } {\n      return { ...cursorPosition }\n    },\n\n    setCursorPosition(x: number, y: number): void {\n      cursorPosition = { x: Math.max(0, x), y: Math.max(0, y) }\n    },\n\n    setCursorVisible(visible: boolean): void {\n      cursorVisible = visible\n    },\n\n    // Extended methods\n    setDimensions(dimensions: TerminalDimensions): void {\n      currentDimensions = { ...dimensions }\n      resizeListeners.forEach((listener) => listener(currentDimensions))\n    },\n\n    dispatchKeyPress(key: string, modifiers: KeyModifiers): void {\n      keypressListeners.forEach((listener) => {\n        listener({ key, modifiers })\n      })\n\n      if (inputResolve) {\n        if (key === \"Enter\") {\n          const value = inputBuffer\n          inputBuffer = \"\"\n          inputResolve(value)\n          inputResolve = null\n          inputReject = null\n        } else if (key === \"Backspace\") {\n          inputBuffer = inputBuffer.slice(0, -1)\n        } else if (key.length === 1) {\n          inputBuffer += key\n        }\n      }\n    },\n\n    getPrompt(): string {\n      return currentPrompt\n    },\n\n    isWaitingForInput(): boolean {\n      return inputResolve !== null\n    },\n\n    cancelInput(): void {\n      if (inputReject) {\n        inputReject(new Error(\"Input cancelled\"))\n        inputResolve = null\n        inputReject = null\n        inputBuffer = \"\"\n      }\n    },\n  }\n\n  return bridge\n}\n\n// Export default factory\nexport { createCLITerminalBridge as default }\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "cli-version-negotiator",
      "type": "registry:lib",
      "title": "CLI Version Negotiator",
      "description": "Semver-based version compatibility and feature negotiation for CLI plugins.",
      "dependencies": [],
      "registryDependencies": [
        "cli-plugin-types"
      ],
      "files": [
        {
          "path": "lib/opentui/plugins/cli/adapters/version-negotiator.ts",
          "content": "// Version Negotiator for CLI Plugin Framework\n// Handles semver-based version compatibility and feature negotiation\n\nimport type { \n  CLILibrary, \n  VersionRange, \n  VersionCompatibility, \n  CLIFeature,\n  VersionFeatureMap \n} from \"../types\"\n\n/** Parsed semantic version */\ninterface ParsedVersion {\n  major: number\n  minor: number\n  patch: number\n  prerelease?: string\n  build?: string\n}\n\n/** Version range operator */\ntype RangeOperator = \"=\" | \">\" | \">=\" | \"<\" | \"<=\" | \"^\" | \"~\"\n\n/** Parsed version range */\ninterface ParsedRange {\n  operator: RangeOperator\n  version: ParsedVersion\n}\n\n/**\n * Parse a semantic version string\n */\nexport function parseVersion(version: string): ParsedVersion {\n  const cleanVersion = version.replace(/^[v=]/, \"\").trim()\n  \n  // Match semver pattern: major.minor.patch[-prerelease][+build]\n  const match = cleanVersion.match(\n    /^(\\d+)\\.(\\d+)\\.(\\d+)(?:-([a-zA-Z0-9.-]+))?(?:\\+([a-zA-Z0-9.-]+))?$/\n  )\n  \n  if (!match) {\n    throw new Error(`Invalid version format: ${version}`)\n  }\n  \n  return {\n    major: parseInt(match[1], 10),\n    minor: parseInt(match[2], 10),\n    patch: parseInt(match[3], 10),\n    prerelease: match[4],\n    build: match[5],\n  }\n}\n\n/**\n * Compare two versions\n * Returns: -1 if a < b, 0 if a = b, 1 if a > b\n */\nexport function compareVersions(a: ParsedVersion, b: ParsedVersion): number {\n  // Compare major\n  if (a.major !== b.major) return a.major < b.major ? -1 : 1\n  \n  // Compare minor\n  if (a.minor !== b.minor) return a.minor < b.minor ? -1 : 1\n  \n  // Compare patch\n  if (a.patch !== b.patch) return a.patch < b.patch ? -1 : 1\n  \n  // Prerelease versions have lower precedence\n  if (a.prerelease && !b.prerelease) return -1\n  if (!a.prerelease && b.prerelease) return 1\n  if (a.prerelease && b.prerelease) {\n    return a.prerelease < b.prerelease ? -1 : a.prerelease > b.prerelease ? 1 : 0\n  }\n  \n  return 0\n}\n\n/**\n * Parse a version range string\n */\nexport function parseRange(range: string): ParsedRange[] {\n  const ranges: ParsedRange[] = []\n  \n  // Split on spaces for multiple conditions (AND)\n  const parts = range.trim().split(/\\s+/)\n  \n  for (const part of parts) {\n    // Check for range operators\n    const match = part.match(/^([><=^~]*)(.+)$/)\n    if (!match) continue\n    \n    let operator: RangeOperator = \"=\"\n    const op = match[1] || \"=\"\n    \n    switch (op) {\n      case \">=\": operator = \">=\"; break\n      case \">\": operator = \">\"; break\n      case \"<=\": operator = \"<=\"; break\n      case \"<\": operator = \"<\"; break\n      case \"^\": operator = \"^\"; break\n      case \"~\": operator = \"~\"; break\n      default: operator = \"=\"; break\n    }\n    \n    try {\n      ranges.push({\n        operator,\n        version: parseVersion(match[2]),\n      })\n    } catch {\n      // Skip invalid versions\n    }\n  }\n  \n  return ranges\n}\n\n/**\n * Check if a version satisfies a single range condition\n */\nfunction satisfiesCondition(version: ParsedVersion, condition: ParsedRange): boolean {\n  const cmp = compareVersions(version, condition.version)\n  \n  switch (condition.operator) {\n    case \"=\":\n      return cmp === 0\n    case \">\":\n      return cmp > 0\n    case \">=\":\n      return cmp >= 0\n    case \"<\":\n      return cmp < 0\n    case \"<=\":\n      return cmp <= 0\n    case \"^\":\n      // Compatible with version (major must match, minor/patch can be higher)\n      if (condition.version.major === 0) {\n        // For 0.x.x, minor must match\n        return (\n          version.major === condition.version.major &&\n          version.minor === condition.version.minor &&\n          version.patch >= condition.version.patch\n        )\n      }\n      return (\n        version.major === condition.version.major &&\n        (version.minor > condition.version.minor ||\n          (version.minor === condition.version.minor &&\n            version.patch >= condition.version.patch))\n      )\n    case \"~\":\n      // Approximately equivalent (patch-level changes allowed)\n      return (\n        version.major === condition.version.major &&\n        version.minor === condition.version.minor &&\n        version.patch >= condition.version.patch\n      )\n    default:\n      return false\n  }\n}\n\n/**\n * Check if a version satisfies a range\n */\nexport function satisfiesRange(version: string, range: VersionRange): boolean {\n  try {\n    const parsed = parseVersion(version)\n    const conditions = parseRange(range)\n    \n    // All conditions must be satisfied (AND logic)\n    return conditions.every((condition) => satisfiesCondition(parsed, condition))\n  } catch {\n    return false\n  }\n}\n\n/**\n * Version Negotiator class\n */\nexport class VersionNegotiator {\n  private versionFeatures: Map<CLILibrary, VersionFeatureMap[]> = new Map()\n  private shimRegistry: Map<string, string[]> = new Map()\n\n  constructor() {\n    // Initialize with default feature maps\n    this.initializeDefaultFeatures()\n  }\n\n  /**\n   * Initialize default feature maps for supported libraries\n   */\n  private initializeDefaultFeatures(): void {\n    // Ink v6.x features\n    this.versionFeatures.set(\"ink\", [\n      {\n        version: \"6.6.0\",\n        features: [\n          \"useInput\",\n          \"useStdin\",\n          \"useStdout\",\n          \"useFocus\",\n          \"flexbox\",\n          \"colors16\",\n          \"colors256\",\n          \"unicode\",\n          \"boxDrawing\",\n        ],\n      },\n      {\n        version: \"6.7.0\",\n        features: [\n          \"useInput\",\n          \"useStdin\",\n          \"useStdout\",\n          \"useFocus\",\n          \"useFocusManager\",\n          \"measureElement\",\n          \"flexbox\",\n          \"colors16\",\n          \"colors256\",\n          \"trueColor\",\n          \"unicode\",\n          \"boxDrawing\",\n        ],\n      },\n      {\n        version: \"6.8.0\",\n        features: [\n          \"useInput\",\n          \"useStdin\",\n          \"useStdout\",\n          \"useFocus\",\n          \"useFocusManager\",\n          \"measureElement\",\n          \"staticOutput\",\n          \"flexbox\",\n          \"colors16\",\n          \"colors256\",\n          \"trueColor\",\n          \"unicode\",\n          \"mouse\",\n          \"boxDrawing\",\n        ],\n      },\n    ])\n\n    // Pastel v4.x features (future)\n    this.versionFeatures.set(\"pastel\", [\n      {\n        version: \"4.0.0\",\n        features: [\n          \"useInput\",\n          \"flexbox\",\n          \"colors16\",\n          \"colors256\",\n          \"trueColor\",\n          \"unicode\",\n          \"boxDrawing\",\n        ],\n      },\n    ])\n  }\n\n  /**\n   * Register feature support for a library version\n   */\n  registerVersion(library: CLILibrary, version: string, features: CLIFeature[]): void {\n    const existing = this.versionFeatures.get(library) || []\n    const versionIndex = existing.findIndex((v) => v.version === version)\n    \n    if (versionIndex >= 0) {\n      existing[versionIndex] = { version, features }\n    } else {\n      existing.push({ version, features })\n      // Sort by version\n      existing.sort((a, b) => compareVersions(parseVersion(a.version), parseVersion(b.version)))\n    }\n    \n    this.versionFeatures.set(library, existing)\n  }\n\n  /**\n   * Register shims needed for version compatibility\n   */\n  registerShim(fromVersion: string, toVersion: string, shims: string[]): void {\n    const key = `${fromVersion}->${toVersion}`\n    this.shimRegistry.set(key, shims)\n  }\n\n  /**\n   * Negotiate the best compatible version\n   */\n  negotiate(\n    library: CLILibrary,\n    requestedRange: VersionRange,\n    availableVersion: string\n  ): VersionCompatibility {\n    const warnings: string[] = []\n    const requiredShims: string[] = []\n    const missingFeatures: CLIFeature[] = []\n\n    // Check if available version satisfies the requested range\n    const compatible = satisfiesRange(availableVersion, requestedRange)\n\n    if (!compatible) {\n      // Try to find what shims might help\n      const requestedParsed = parseRange(requestedRange)\n      if (requestedParsed.length > 0) {\n        const requestedVersion = `${requestedParsed[0].version.major}.${requestedParsed[0].version.minor}.${requestedParsed[0].version.patch}`\n        const shimKey = `${requestedVersion}->${availableVersion}`\n        const shims = this.shimRegistry.get(shimKey)\n        if (shims) {\n          requiredShims.push(...shims)\n          warnings.push(`Version mismatch: requested ${requestedRange}, available ${availableVersion}. Shims may help.`)\n        } else {\n          warnings.push(`Version mismatch: requested ${requestedRange}, available ${availableVersion}. No shims available.`)\n        }\n      }\n    }\n\n    // Check for missing features\n    const libraryVersions = this.versionFeatures.get(library) || []\n    const requestedFeatures = this.getFeaturesForVersionInternal(libraryVersions, requestedRange)\n    const availableFeatures = this.getFeaturesForVersionInternal(libraryVersions, availableVersion)\n\n    for (const feature of requestedFeatures) {\n      if (!availableFeatures.includes(feature)) {\n        missingFeatures.push(feature)\n      }\n    }\n\n    if (missingFeatures.length > 0) {\n      warnings.push(`Missing features in ${availableVersion}: ${missingFeatures.join(\", \")}`)\n    }\n\n    return {\n      compatible,\n      negotiatedVersion: availableVersion,\n      warnings: warnings.length > 0 ? warnings : undefined,\n      requiredShims: requiredShims.length > 0 ? requiredShims : undefined,\n      missingFeatures: missingFeatures.length > 0 ? missingFeatures : undefined,\n    }\n  }\n\n  /**\n   * Get features for a specific version\n   */\n  private getFeaturesForVersionInternal(\n    versions: VersionFeatureMap[],\n    versionOrRange: string\n  ): CLIFeature[] {\n    // Find the best matching version\n    for (let i = versions.length - 1; i >= 0; i--) {\n      if (satisfiesRange(versions[i].version, versionOrRange)) {\n        return versions[i].features\n      }\n    }\n    \n    // If no exact match, return features from the highest compatible version\n    for (let i = versions.length - 1; i >= 0; i--) {\n      try {\n        const vParsed = parseVersion(versions[i].version)\n        const ranges = parseRange(versionOrRange)\n        if (ranges.length > 0) {\n          const cmp = compareVersions(vParsed, ranges[0].version)\n          if (cmp >= 0) {\n            return versions[i].features\n          }\n        }\n      } catch {\n        continue\n      }\n    }\n    \n    return []\n  }\n\n  /**\n   * Get features available for a library at a specific version\n   */\n  getFeaturesForVersion(library: CLILibrary, version: string): CLIFeature[] {\n    const versions = this.versionFeatures.get(library) || []\n    return this.getFeaturesForVersionInternal(versions, version)\n  }\n\n  /**\n   * Check if a feature is available for a library at a specific version\n   */\n  isFeatureAvailable(library: CLILibrary, version: string, feature: CLIFeature): boolean {\n    const features = this.getFeaturesForVersion(library, version)\n    return features.includes(feature)\n  }\n\n  /**\n   * Get required shims for version gap\n   */\n  getRequiredShims(fromVersion: string, toVersion: string): string[] {\n    const key = `${fromVersion}->${toVersion}`\n    return this.shimRegistry.get(key) || []\n  }\n\n  /**\n   * Get all registered versions for a library\n   */\n  getRegisteredVersions(library: CLILibrary): string[] {\n    const versions = this.versionFeatures.get(library) || []\n    return versions.map((v) => v.version)\n  }\n}\n\n// Export singleton instance\nexport const versionNegotiator = new VersionNegotiator()\n\n// Export utility functions\nexport { parseVersion, compareVersions, satisfiesRange }\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "cli-base-adapter",
      "type": "registry:lib",
      "title": "CLI Base Adapter",
      "description": "Abstract base class for CLI library adapters.",
      "dependencies": [],
      "registryDependencies": [
        "cli-plugin-types",
        "cli-version-negotiator"
      ],
      "files": [
        {
          "path": "lib/opentui/plugins/cli/adapters/base-adapter.ts",
          "content": "// Base Adapter for CLI Plugin Framework\n// Abstract base class that all library adapters extend\n\nimport type {\n  ICLIAdapter,\n  CLILibrary,\n  VersionRange,\n  VersionCompatibility,\n  CLIFeature,\n  CLITerminalBridge,\n  CLIRenderInstance,\n} from \"../types\"\nimport { versionNegotiator, satisfiesRange } from \"./version-negotiator\"\n\n/**\n * Generate a unique ID\n */\nfunction generateId(): string {\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n}\n\n/**\n * Abstract base adapter class\n * Provides common functionality for all CLI library adapters\n */\nexport abstract class BaseCLIAdapter implements ICLIAdapter {\n  abstract readonly library: CLILibrary\n  abstract readonly adapterVersion: string\n  abstract readonly supportedVersions: VersionRange\n\n  protected initialized = false\n  protected activeInstances = new Map<string, CLIRenderInstance>()\n\n  /**\n   * Initialize the adapter\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return\n    }\n    await this.doInitialize()\n    this.initialized = true\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async destroy(): Promise<void> {\n    if (!this.initialized) {\n      return\n    }\n    \n    // Unmount all active instances\n    for (const instance of this.activeInstances.values()) {\n      try {\n        instance.unmount()\n      } catch {\n        // Ignore unmount errors during cleanup\n      }\n    }\n    this.activeInstances.clear()\n    \n    await this.doDestroy()\n    this.initialized = false\n  }\n\n  /**\n   * Check version compatibility\n   */\n  checkCompatibility(requestedVersion: string): VersionCompatibility {\n    return versionNegotiator.negotiate(\n      this.library,\n      requestedVersion,\n      this.getAdapterLibraryVersion()\n    )\n  }\n\n  /**\n   * Create a render instance\n   */\n  createRenderInstance(\n    component: React.ComponentType<unknown>,\n    props: Record<string, unknown>,\n    bridge: CLITerminalBridge\n  ): CLIRenderInstance {\n    if (!this.initialized) {\n      throw new Error(`Adapter for ${this.library} is not initialized`)\n    }\n\n    const id = generateId()\n    const instance = this.doCreateRenderInstance(id, component, props, bridge)\n    this.activeInstances.set(id, instance)\n\n    // Remove from tracking when unmounted\n    const originalUnmount = instance.unmount.bind(instance)\n    instance.unmount = () => {\n      this.activeInstances.delete(id)\n      originalUnmount()\n    }\n\n    return instance\n  }\n\n  /**\n   * Check if a feature is supported\n   */\n  supportsFeature(feature: CLIFeature): boolean {\n    return this.getSupportedFeatures().includes(feature)\n  }\n\n  /**\n   * Get features for a specific version\n   */\n  getFeaturesForVersion(version: string): CLIFeature[] {\n    if (!satisfiesRange(version, this.supportedVersions)) {\n      return []\n    }\n    return versionNegotiator.getFeaturesForVersion(this.library, version)\n  }\n\n  /**\n   * Transform props for version compatibility\n   */\n  transformProps?(props: Record<string, unknown>, targetVersion: string): Record<string, unknown> {\n    // Default: no transformation\n    return props\n  }\n\n  // ============================================\n  // Abstract methods to be implemented by subclasses\n  // ============================================\n\n  /**\n   * Perform adapter-specific initialization\n   */\n  protected abstract doInitialize(): Promise<void>\n\n  /**\n   * Perform adapter-specific cleanup\n   */\n  protected abstract doDestroy(): Promise<void>\n\n  /**\n   * Create an adapter-specific render instance\n   */\n  protected abstract doCreateRenderInstance(\n    id: string,\n    component: React.ComponentType<unknown>,\n    props: Record<string, unknown>,\n    bridge: CLITerminalBridge\n  ): CLIRenderInstance\n\n  /**\n   * Get the library version this adapter uses\n   */\n  protected abstract getAdapterLibraryVersion(): string\n\n  /**\n   * Get list of supported features\n   */\n  protected abstract getSupportedFeatures(): CLIFeature[]\n}\n\n/**\n * Base render instance class\n */\nexport abstract class BaseRenderInstance implements CLIRenderInstance {\n  readonly id: string\n  protected _isActive = true\n  protected _isPaused = false\n  protected exitCode: number | null = null\n  protected exitResolve: ((code: number) => void) | null = null\n\n  constructor(id: string) {\n    this.id = id\n  }\n\n  /**\n   * Re-render with new props\n   */\n  abstract rerender(props?: Record<string, unknown>): void\n\n  /**\n   * Unmount the component\n   */\n  unmount(): void {\n    if (!this._isActive) return\n    this._isActive = false\n    this.doUnmount()\n    if (this.exitResolve) {\n      this.exitResolve(this.exitCode ?? 0)\n    }\n  }\n\n  /**\n   * Wait for exit\n   */\n  waitUntilExit(): Promise<number> {\n    if (!this._isActive) {\n      return Promise.resolve(this.exitCode ?? 0)\n    }\n    return new Promise((resolve) => {\n      this.exitResolve = resolve\n    })\n  }\n\n  /**\n   * Clear rendered content\n   */\n  abstract clear(): void\n\n  /**\n   * Pause rendering\n   */\n  pause(): void {\n    if (!this._isActive) return\n    this._isPaused = true\n    this.doPause()\n  }\n\n  /**\n   * Resume rendering\n   */\n  resume(): void {\n    if (!this._isActive) return\n    this._isPaused = false\n    this.doResume()\n  }\n\n  /**\n   * Check if instance is active\n   */\n  isActive(): boolean {\n    return this._isActive\n  }\n\n  /**\n   * Set exit code\n   */\n  protected setExitCode(code: number): void {\n    this.exitCode = code\n  }\n\n  // Abstract methods for subclasses\n  protected abstract doUnmount(): void\n  protected abstract doPause(): void\n  protected abstract doResume(): void\n}\n\nexport { generateId }\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "cli-ink-adapter",
      "type": "registry:lib",
      "title": "Ink v6 Adapter",
      "description": "Adapter for Ink v6.6.0+ CLI components. Bridges Ink apps to OpenTUI terminal.",
      "dependencies": [
        "ink@^6.6.0"
      ],
      "registryDependencies": [
        "cli-plugin-types",
        "cli-base-adapter",
        "cli-version-negotiator"
      ],
      "files": [
        {
          "path": "lib/opentui/plugins/cli/adapters/ink-adapter.ts",
          "content": "// Ink v6.6.0+ Adapter for CLI Plugin Framework\n// Bridges Ink CLI components to OpenTUI terminal\n\nimport type {\n  CLILibrary,\n  VersionRange,\n  CLIFeature,\n  CLITerminalBridge,\n  CLIRenderInstance,\n} from \"../types\"\nimport { BaseCLIAdapter, BaseRenderInstance, generateId } from \"./base-adapter\"\n\n/**\n * Configuration options for the Ink adapter\n */\nexport interface InkAdapterOptions {\n  /** Enable debug mode */\n  debug?: boolean\n  /** Render output to terminal bridge instead of stdout */\n  useTerminalBridge?: boolean\n  /** Patch interval for updates (ms) */\n  patchInterval?: number\n}\n\n/**\n * Default Ink adapter options\n */\nconst DEFAULT_OPTIONS: Required<InkAdapterOptions> = {\n  debug: false,\n  useTerminalBridge: true,\n  patchInterval: 16, // ~60fps\n}\n\n/**\n * Ink v6 supported features by version\n */\nconst INK_FEATURES: Record<string, CLIFeature[]> = {\n  \"6.6.0\": [\n    \"useInput\",\n    \"useStdin\",\n    \"useStdout\",\n    \"useFocus\",\n    \"flexbox\",\n    \"colors16\",\n    \"colors256\",\n    \"unicode\",\n    \"boxDrawing\",\n  ],\n  \"6.7.0\": [\n    \"useInput\",\n    \"useStdin\",\n    \"useStdout\",\n    \"useFocus\",\n    \"useFocusManager\",\n    \"measureElement\",\n    \"flexbox\",\n    \"colors16\",\n    \"colors256\",\n    \"trueColor\",\n    \"unicode\",\n    \"boxDrawing\",\n  ],\n  \"6.8.0\": [\n    \"useInput\",\n    \"useStdin\",\n    \"useStdout\",\n    \"useFocus\",\n    \"useFocusManager\",\n    \"measureElement\",\n    \"staticOutput\",\n    \"flexbox\",\n    \"colors16\",\n    \"colors256\",\n    \"trueColor\",\n    \"unicode\",\n    \"mouse\",\n    \"boxDrawing\",\n  ],\n}\n\n/**\n * Ink render instance that bridges to OpenTUI\n */\nclass InkRenderInstance extends BaseRenderInstance {\n  private component: React.ComponentType<unknown>\n  private props: Record<string, unknown>\n  private bridge: CLITerminalBridge\n  private renderCallback: (() => void) | null = null\n  private outputBuffer: string[] = []\n  private options: Required<InkAdapterOptions>\n\n  constructor(\n    id: string,\n    component: React.ComponentType<unknown>,\n    props: Record<string, unknown>,\n    bridge: CLITerminalBridge,\n    options: Required<InkAdapterOptions>\n  ) {\n    super(id)\n    this.component = component\n    this.props = props\n    this.bridge = bridge\n    this.options = options\n    \n    // Start rendering\n    this.startRender()\n  }\n\n  /**\n   * Start the render loop\n   */\n  private startRender(): void {\n    // In a full implementation, this would integrate with Ink's render function\n    // For now, we simulate the render cycle with a callback pattern\n    this.render()\n  }\n\n  /**\n   * Perform a render cycle\n   */\n  private render(): void {\n    if (!this._isActive || this._isPaused) return\n\n    try {\n      // In a real implementation, this would call Ink's render function\n      // and capture the output to send to the terminal bridge\n      \n      // For demonstration, we'll emit a placeholder that shows the component is running\n      if (this.options.debug) {\n        this.bridge.writeLine(`[Ink] Rendering component: ${this.component.name || \"Anonymous\"}`, \"system\")\n      }\n    } catch (error) {\n      if (this.options.debug) {\n        this.bridge.writeLine(`[Ink] Render error: ${error}`, \"error\")\n      }\n    }\n  }\n\n  rerender(props?: Record<string, unknown>): void {\n    if (!this._isActive) return\n    if (props) {\n      this.props = { ...this.props, ...props }\n    }\n    this.render()\n  }\n\n  clear(): void {\n    this.outputBuffer = []\n    this.bridge.clear()\n  }\n\n  protected doUnmount(): void {\n    this.renderCallback = null\n    this.outputBuffer = []\n  }\n\n  protected doPause(): void {\n    // Stop render updates but keep state\n  }\n\n  protected doResume(): void {\n    // Resume render updates\n    this.render()\n  }\n\n  /**\n   * Write output to terminal bridge\n   */\n  writeOutput(content: string): void {\n    this.outputBuffer.push(content)\n    this.bridge.writeLine(content)\n  }\n\n  /**\n   * Get current props\n   */\n  getProps(): Record<string, unknown> {\n    return { ...this.props }\n  }\n\n  /**\n   * Set exit code and trigger exit\n   */\n  exit(code: number = 0): void {\n    this.setExitCode(code)\n    this.unmount()\n  }\n}\n\n/**\n * Ink v6.6.0+ Adapter\n * \n * This adapter provides integration between Ink CLI components and OpenTUI.\n * It supports Ink version 6.6.0 and above, with feature detection for\n * version-specific capabilities.\n */\nexport class InkAdapter extends BaseCLIAdapter {\n  readonly library: CLILibrary = \"ink\"\n  readonly adapterVersion = \"1.0.0\"\n  readonly supportedVersions: VersionRange = \">=6.6.0 <7.0.0\"\n\n  private options: Required<InkAdapterOptions>\n  private currentLibraryVersion = \"6.6.0\" // Default to minimum supported\n\n  constructor(options: InkAdapterOptions = {}) {\n    super()\n    this.options = { ...DEFAULT_OPTIONS, ...options }\n  }\n\n  /**\n   * Set the target Ink library version\n   * This allows apps to specify which version's features they need\n   */\n  setTargetVersion(version: string): void {\n    this.currentLibraryVersion = version\n  }\n\n  protected async doInitialize(): Promise<void> {\n    // In a full implementation, this would:\n    // 1. Dynamically import the Ink package\n    // 2. Verify the installed version\n    // 3. Set up any global Ink configuration\n    \n    if (this.options.debug) {\n      console.log(`[InkAdapter] Initialized for Ink ${this.supportedVersions}`)\n    }\n  }\n\n  protected async doDestroy(): Promise<void> {\n    // Cleanup any Ink-specific resources\n    if (this.options.debug) {\n      console.log(\"[InkAdapter] Destroyed\")\n    }\n  }\n\n  protected doCreateRenderInstance(\n    id: string,\n    component: React.ComponentType<unknown>,\n    props: Record<string, unknown>,\n    bridge: CLITerminalBridge\n  ): CLIRenderInstance {\n    return new InkRenderInstance(id, component, props, bridge, this.options)\n  }\n\n  protected getAdapterLibraryVersion(): string {\n    return this.currentLibraryVersion\n  }\n\n  protected getSupportedFeatures(): CLIFeature[] {\n    // Get features for current library version\n    const version = this.currentLibraryVersion\n    \n    // Find the best matching feature set\n    const versionKeys = Object.keys(INK_FEATURES).sort()\n    let features: CLIFeature[] = []\n    \n    for (const v of versionKeys) {\n      if (this.compareVersions(version, v) >= 0) {\n        features = INK_FEATURES[v]\n      }\n    }\n    \n    return features\n  }\n\n  /**\n   * Compare two version strings\n   */\n  private compareVersions(a: string, b: string): number {\n    const partsA = a.split(\".\").map(Number)\n    const partsB = b.split(\".\").map(Number)\n    \n    for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {\n      const partA = partsA[i] || 0\n      const partB = partsB[i] || 0\n      if (partA !== partB) {\n        return partA - partB\n      }\n    }\n    \n    return 0\n  }\n\n  /**\n   * Transform props for version compatibility\n   * Handles API changes between Ink versions\n   */\n  transformProps(props: Record<string, unknown>, targetVersion: string): Record<string, unknown> {\n    const transformed = { ...props }\n    \n    // Example: Handle API changes between versions\n    // In a real implementation, this would handle breaking changes\n    \n    // 6.6.0 -> 6.7.0: No breaking changes\n    // 6.7.0 -> 6.8.0: Mouse support added, may need to disable by default\n    \n    if (this.compareVersions(targetVersion, \"6.8.0\") >= 0) {\n      // Enable mouse support by default in 6.8.0+\n      if (transformed.enableMouse === undefined) {\n        transformed.enableMouse = false // Opt-in for compatibility\n      }\n    }\n    \n    return transformed\n  }\n\n  /**\n   * Create an Ink component wrapper that integrates with OpenTUI\n   */\n  createComponentWrapper<P extends Record<string, unknown>>(\n    InkComponent: React.ComponentType<P>,\n    bridge: CLITerminalBridge\n  ): React.ComponentType<P> {\n    // This would wrap the Ink component with OpenTUI integration\n    // In a full implementation, this would:\n    // 1. Intercept Ink's stdout/stderr\n    // 2. Route output through the terminal bridge\n    // 3. Handle input from the bridge\n    \n    return InkComponent\n  }\n}\n\n/**\n * Create an Ink adapter instance\n */\nexport function createInkAdapter(options?: InkAdapterOptions): InkAdapter {\n  return new InkAdapter(options)\n}\n\n// Export for type inference\nexport type { InkRenderInstance }\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "cli-pastel-adapter",
      "type": "registry:lib",
      "title": "Pastel v4 Adapter",
      "description": "Adapter for Pastel v4.0.0+ CLI components (future implementation).",
      "dependencies": [],
      "registryDependencies": [
        "cli-plugin-types",
        "cli-base-adapter",
        "cli-version-negotiator"
      ],
      "files": [
        {
          "path": "lib/opentui/plugins/cli/adapters/pastel-adapter.ts",
          "content": "// Pastel v4.0.0+ Adapter for CLI Plugin Framework\n// Provides integration for Pastel CLI applications (future implementation)\n\nimport type {\n  CLILibrary,\n  VersionRange,\n  CLIFeature,\n  CLITerminalBridge,\n  CLIRenderInstance,\n} from \"../types\"\nimport { BaseCLIAdapter, BaseRenderInstance } from \"./base-adapter\"\n\n/**\n * Configuration options for the Pastel adapter\n */\nexport interface PastelAdapterOptions {\n  /** Enable debug mode */\n  debug?: boolean\n  /** Theme configuration */\n  theme?: PastelTheme\n}\n\n/**\n * Pastel theme configuration\n */\nexport interface PastelTheme {\n  primaryColor?: string\n  secondaryColor?: string\n  backgroundColor?: string\n  textColor?: string\n}\n\n/**\n * Default Pastel adapter options\n */\nconst DEFAULT_OPTIONS: Required<PastelAdapterOptions> = {\n  debug: false,\n  theme: {\n    primaryColor: \"cyan\",\n    secondaryColor: \"magenta\",\n    backgroundColor: \"black\",\n    textColor: \"white\",\n  },\n}\n\n/**\n * Pastel v4 supported features by version\n */\nconst PASTEL_FEATURES: Record<string, CLIFeature[]> = {\n  \"4.0.0\": [\n    \"useInput\",\n    \"flexbox\",\n    \"colors16\",\n    \"colors256\",\n    \"trueColor\",\n    \"unicode\",\n    \"boxDrawing\",\n  ],\n  \"4.1.0\": [\n    \"useInput\",\n    \"useFocus\",\n    \"flexbox\",\n    \"colors16\",\n    \"colors256\",\n    \"trueColor\",\n    \"unicode\",\n    \"boxDrawing\",\n    \"hyperlinks\",\n  ],\n}\n\n/**\n * Pastel render instance\n */\nclass PastelRenderInstance extends BaseRenderInstance {\n  private component: React.ComponentType<unknown>\n  private props: Record<string, unknown>\n  private bridge: CLITerminalBridge\n  private options: Required<PastelAdapterOptions>\n\n  constructor(\n    id: string,\n    component: React.ComponentType<unknown>,\n    props: Record<string, unknown>,\n    bridge: CLITerminalBridge,\n    options: Required<PastelAdapterOptions>\n  ) {\n    super(id)\n    this.component = component\n    this.props = props\n    this.bridge = bridge\n    this.options = options\n  }\n\n  rerender(props?: Record<string, unknown>): void {\n    if (!this._isActive) return\n    if (props) {\n      this.props = { ...this.props, ...props }\n    }\n    // Render logic would go here\n  }\n\n  clear(): void {\n    this.bridge.clear()\n  }\n\n  protected doUnmount(): void {\n    // Cleanup\n  }\n\n  protected doPause(): void {\n    // Pause rendering\n  }\n\n  protected doResume(): void {\n    // Resume rendering\n  }\n}\n\n/**\n * Pastel v4.0.0+ Adapter\n * \n * This adapter provides integration between Pastel CLI components and OpenTUI.\n * Pastel is an alternative CLI framework that may be supported in the future.\n * \n * Note: This is a stub implementation for future extension.\n */\nexport class PastelAdapter extends BaseCLIAdapter {\n  readonly library: CLILibrary = \"pastel\"\n  readonly adapterVersion = \"1.0.0\"\n  readonly supportedVersions: VersionRange = \">=4.0.0 <5.0.0\"\n\n  private options: Required<PastelAdapterOptions>\n  private currentLibraryVersion = \"4.0.0\"\n\n  constructor(options: PastelAdapterOptions = {}) {\n    super()\n    this.options = { \n      ...DEFAULT_OPTIONS, \n      ...options,\n      theme: { ...DEFAULT_OPTIONS.theme, ...options.theme },\n    }\n  }\n\n  /**\n   * Set the target Pastel library version\n   */\n  setTargetVersion(version: string): void {\n    this.currentLibraryVersion = version\n  }\n\n  protected async doInitialize(): Promise<void> {\n    if (this.options.debug) {\n      console.log(`[PastelAdapter] Initialized for Pastel ${this.supportedVersions}`)\n    }\n  }\n\n  protected async doDestroy(): Promise<void> {\n    if (this.options.debug) {\n      console.log(\"[PastelAdapter] Destroyed\")\n    }\n  }\n\n  protected doCreateRenderInstance(\n    id: string,\n    component: React.ComponentType<unknown>,\n    props: Record<string, unknown>,\n    bridge: CLITerminalBridge\n  ): CLIRenderInstance {\n    return new PastelRenderInstance(id, component, props, bridge, this.options)\n  }\n\n  protected getAdapterLibraryVersion(): string {\n    return this.currentLibraryVersion\n  }\n\n  protected getSupportedFeatures(): CLIFeature[] {\n    const version = this.currentLibraryVersion\n    const versionKeys = Object.keys(PASTEL_FEATURES).sort()\n    let features: CLIFeature[] = []\n    \n    for (const v of versionKeys) {\n      if (this.compareVersions(version, v) >= 0) {\n        features = PASTEL_FEATURES[v]\n      }\n    }\n    \n    return features\n  }\n\n  private compareVersions(a: string, b: string): number {\n    const partsA = a.split(\".\").map(Number)\n    const partsB = b.split(\".\").map(Number)\n    \n    for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {\n      const partA = partsA[i] || 0\n      const partB = partsB[i] || 0\n      if (partA !== partB) {\n        return partA - partB\n      }\n    }\n    \n    return 0\n  }\n\n  transformProps(props: Record<string, unknown>, targetVersion: string): Record<string, unknown> {\n    return { ...props }\n  }\n}\n\n/**\n * Create a Pastel adapter instance\n */\nexport function createPastelAdapter(options?: PastelAdapterOptions): PastelAdapter {\n  return new PastelAdapter(options)\n}\n\nexport type { PastelRenderInstance }\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "cli-adapters",
      "type": "registry:lib",
      "title": "CLI Adapters",
      "description": "All CLI library adapters (Ink, Pastel) with version negotiation.",
      "dependencies": [
        "ink@^6.6.0"
      ],
      "registryDependencies": [
        "cli-base-adapter",
        "cli-ink-adapter",
        "cli-pastel-adapter",
        "cli-version-negotiator"
      ],
      "files": [
        {
          "path": "lib/opentui/plugins/cli/adapters/index.ts",
          "content": "// CLI Plugin Framework Adapters\n// Export all adapter implementations and utilities\n\n// Base adapter\nexport { BaseCLIAdapter, BaseRenderInstance, generateId } from \"./base-adapter\"\n\n// Version negotiator\nexport { \n  VersionNegotiator, \n  versionNegotiator,\n  parseVersion,\n  compareVersions,\n  satisfiesRange,\n} from \"./version-negotiator\"\n\n// Ink adapter\nexport { InkAdapter, createInkAdapter } from \"./ink-adapter\"\nexport type { InkAdapterOptions, InkRenderInstance } from \"./ink-adapter\"\n\n// Pastel adapter (future)\nexport { PastelAdapter, createPastelAdapter } from \"./pastel-adapter\"\nexport type { PastelAdapterOptions, PastelTheme, PastelRenderInstance } from \"./pastel-adapter\"\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "cli-app-registry",
      "type": "registry:lib",
      "title": "CLI App Registry",
      "description": "Registry for managing CLI application registration and lookup.",
      "dependencies": [],
      "registryDependencies": [
        "cli-plugin-types"
      ],
      "files": [
        {
          "path": "lib/opentui/plugins/cli/cli-app-registry.ts",
          "content": "// CLI App Registry\n// Manages registration and lookup of CLI applications\n\nimport type { \n  CLIAppDefinition, \n  CLIAppRegistry, \n  CLILibrary,\n  CLIAdapterRegistry,\n  ICLIAdapter,\n  VersionRange,\n} from \"./types\"\n\n/**\n * Implementation of CLIAppRegistry\n */\nclass CLIAppRegistryImpl implements CLIAppRegistry {\n  private apps = new Map<string, CLIAppDefinition>()\n  private aliasMap = new Map<string, string>() // alias -> name\n\n  register(app: CLIAppDefinition): void {\n    if (!app.manifest.name) {\n      throw new Error(\"App manifest must have a name\")\n    }\n\n    const name = app.manifest.name\n\n    if (this.apps.has(name)) {\n      throw new Error(`App \"${name}\" is already registered`)\n    }\n\n    this.apps.set(name, app)\n\n    // Register entry command as alias if specified\n    if (app.manifest.entryCommand && app.manifest.entryCommand !== name) {\n      this.aliasMap.set(app.manifest.entryCommand, name)\n    }\n\n    // Register command aliases\n    if (app.commands) {\n      for (const cmd of app.commands) {\n        if (cmd.aliases) {\n          for (const alias of cmd.aliases) {\n            const aliasKey = `${name}:${alias}`\n            this.aliasMap.set(aliasKey, `${name}:${cmd.name}`)\n          }\n        }\n      }\n    }\n\n    // Call lifecycle hook\n    if (app.lifecycle?.onRegister) {\n      app.lifecycle.onRegister(this)\n    }\n  }\n\n  unregister(name: string): void {\n    const app = this.apps.get(name)\n    if (!app) return\n\n    // Remove aliases\n    if (app.manifest.entryCommand) {\n      this.aliasMap.delete(app.manifest.entryCommand)\n    }\n\n    if (app.commands) {\n      for (const cmd of app.commands) {\n        if (cmd.aliases) {\n          for (const alias of cmd.aliases) {\n            this.aliasMap.delete(`${name}:${alias}`)\n          }\n        }\n      }\n    }\n\n    this.apps.delete(name)\n  }\n\n  get(name: string): CLIAppDefinition | undefined {\n    // Check direct name first\n    if (this.apps.has(name)) {\n      return this.apps.get(name)\n    }\n\n    // Check aliases\n    const resolvedName = this.aliasMap.get(name)\n    if (resolvedName) {\n      return this.apps.get(resolvedName)\n    }\n\n    return undefined\n  }\n\n  list(): CLIAppDefinition[] {\n    return Array.from(this.apps.values())\n  }\n\n  has(name: string): boolean {\n    return this.apps.has(name) || this.aliasMap.has(name)\n  }\n\n  getByLibrary(library: CLILibrary): CLIAppDefinition[] {\n    return this.list().filter((app) => app.manifest.library === library)\n  }\n\n  search(query: string): CLIAppDefinition[] {\n    const lowerQuery = query.toLowerCase()\n    \n    return this.list().filter((app) => {\n      const { name, description, keywords } = app.manifest\n      \n      // Search in name\n      if (name.toLowerCase().includes(lowerQuery)) return true\n      \n      // Search in description\n      if (description?.toLowerCase().includes(lowerQuery)) return true\n      \n      // Search in keywords\n      if (keywords?.some((kw) => kw.toLowerCase().includes(lowerQuery))) return true\n      \n      // Search in commands\n      if (app.commands?.some((cmd) => \n        cmd.name.toLowerCase().includes(lowerQuery) ||\n        cmd.description.toLowerCase().includes(lowerQuery)\n      )) return true\n      \n      return false\n    })\n  }\n\n  count(): number {\n    return this.apps.size\n  }\n\n  /**\n   * Clear all registered apps\n   */\n  clear(): void {\n    this.apps.clear()\n    this.aliasMap.clear()\n  }\n\n  /**\n   * Get all registered app names\n   */\n  getNames(): string[] {\n    return Array.from(this.apps.keys())\n  }\n\n  /**\n   * Export registry data for persistence\n   */\n  export(): { apps: CLIAppDefinition[]; aliases: Record<string, string> } {\n    return {\n      apps: this.list(),\n      aliases: Object.fromEntries(this.aliasMap),\n    }\n  }\n}\n\n/**\n * Implementation of CLIAdapterRegistry\n */\nclass CLIAdapterRegistryImpl implements CLIAdapterRegistry {\n  private adapters = new Map<CLILibrary, ICLIAdapter>()\n\n  register(adapter: ICLIAdapter): void {\n    const library = adapter.library\n    \n    if (this.adapters.has(library)) {\n      console.warn(`Overwriting existing adapter for library: ${library}`)\n    }\n    \n    this.adapters.set(library, adapter)\n  }\n\n  unregister(library: CLILibrary): void {\n    this.adapters.delete(library)\n  }\n\n  getAdapter(library: CLILibrary): ICLIAdapter | undefined {\n    return this.adapters.get(library)\n  }\n\n  list(): ICLIAdapter[] {\n    return Array.from(this.adapters.values())\n  }\n\n  supportsLibrary(library: CLILibrary): boolean {\n    return this.adapters.has(library)\n  }\n\n  getSupportedVersions(library: CLILibrary): VersionRange | undefined {\n    const adapter = this.adapters.get(library)\n    return adapter?.supportedVersions\n  }\n\n  /**\n   * Clear all registered adapters\n   */\n  clear(): void {\n    this.adapters.clear()\n  }\n\n  /**\n   * Get count of registered adapters\n   */\n  count(): number {\n    return this.adapters.size\n  }\n}\n\n/**\n * Create a new CLI app registry instance\n */\nexport function createCLIAppRegistry(): CLIAppRegistry {\n  return new CLIAppRegistryImpl()\n}\n\n/**\n * Create a new CLI adapter registry instance\n */\nexport function createCLIAdapterRegistry(): CLIAdapterRegistry {\n  return new CLIAdapterRegistryImpl()\n}\n\n// Export implementation classes for advanced use\nexport { CLIAppRegistryImpl, CLIAdapterRegistryImpl }\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "cli-plugin-host",
      "type": "registry:lib",
      "title": "CLI Plugin Host",
      "description": "Host for managing CLI app execution, lifecycle, and adapters.",
      "dependencies": [
        "ink@^6.6.0"
      ],
      "registryDependencies": [
        "cli-plugin-types",
        "cli-app-registry",
        "cli-terminal-bridge",
        "cli-ink-adapter"
      ],
      "files": [
        {
          "path": "lib/opentui/plugins/cli/cli-plugin-host.ts",
          "content": "// CLI Plugin Host\n// Manages CLI app execution and lifecycle\n\nimport type {\n  CLIPluginHost,\n  CLIPluginHostOptions,\n  CLIAppDefinition,\n  CLIAppInstance,\n  CLIAppStatus,\n  CLIAppContext,\n  CLISignal,\n  CLILibrary,\n  ICLIAdapter,\n  CLIRenderInstance,\n} from \"./types\"\nimport type { OpenTUIRuntimeContext } from \"../../types\"\nimport { createCLIAppRegistry, createCLIAdapterRegistry } from \"./cli-app-registry\"\nimport { createExtendedCLITerminalBridge, type ExtendedCLITerminalBridge } from \"./cli-terminal-bridge\"\nimport { createInkAdapter } from \"./adapters/ink-adapter\"\n\n/**\n * Generate a unique ID\n */\nfunction generateId(): string {\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n}\n\n/**\n * Generate a pseudo process ID\n */\nlet pidCounter = 1000\nfunction generatePid(): number {\n  return pidCounter++\n}\n\n/**\n * CLI App Instance Implementation\n */\nclass CLIAppInstanceImpl implements CLIAppInstance {\n  readonly id: string\n  readonly app: CLIAppDefinition\n  readonly startTime: Date\n  readonly pid: number\n  \n  status: CLIAppStatus = \"starting\"\n  exitCode?: number\n  error?: Error\n\n  private renderInstance: CLIRenderInstance | null = null\n  private bridge: ExtendedCLITerminalBridge | null = null\n  private statusListeners = new Set<(status: CLIAppStatus) => void>()\n  private exitListeners = new Set<(code: number) => void>()\n  private errorListeners = new Set<(error: Error) => void>()\n  private outputListeners = new Set<(output: string) => void>()\n\n  constructor(\n    id: string,\n    app: CLIAppDefinition,\n    renderInstance: CLIRenderInstance,\n    bridge: ExtendedCLITerminalBridge\n  ) {\n    this.id = id\n    this.app = app\n    this.startTime = new Date()\n    this.pid = generatePid()\n    this.renderInstance = renderInstance\n    this.bridge = bridge\n    this.status = \"running\"\n  }\n\n  private setStatus(status: CLIAppStatus): void {\n    this.status = status\n    this.statusListeners.forEach((listener) => listener(status))\n  }\n\n  suspend(): void {\n    if (this.status !== \"running\") return\n    this.setStatus(\"suspended\")\n    this.renderInstance?.pause()\n    this.app.lifecycle?.onSuspend?.()\n  }\n\n  resume(): void {\n    if (this.status !== \"suspended\") return\n    this.setStatus(\"running\")\n    this.renderInstance?.resume()\n    this.app.lifecycle?.onResume?.()\n  }\n\n  terminate(code: number = 0): void {\n    if (this.status === \"terminated\" || this.status === \"exiting\") return\n    \n    this.setStatus(\"exiting\")\n    this.exitCode = code\n    \n    try {\n      this.renderInstance?.unmount()\n    } catch (err) {\n      // Ignore unmount errors\n    }\n    \n    this.setStatus(\"terminated\")\n    this.app.lifecycle?.onExit?.(code)\n    this.exitListeners.forEach((listener) => listener(code))\n  }\n\n  sendInput(input: string): void {\n    if (this.status !== \"running\" || !this.bridge) return\n    this.bridge.dispatchKeyPress(input, { ctrl: false, alt: false, shift: false, meta: false })\n  }\n\n  sendSignal(signal: CLISignal): void {\n    switch (signal) {\n      case \"SIGINT\":\n      case \"SIGTERM\":\n        this.terminate(130) // Standard exit code for SIGINT\n        break\n      case \"SIGKILL\":\n        this.terminate(137) // Standard exit code for SIGKILL\n        break\n      case \"SIGHUP\":\n        this.terminate(129) // Standard exit code for SIGHUP\n        break\n      default:\n        // Custom signals - notify but don't terminate\n        break\n    }\n  }\n\n  onStatusChange(callback: (status: CLIAppStatus) => void): () => void {\n    this.statusListeners.add(callback)\n    return () => this.statusListeners.delete(callback)\n  }\n\n  onExit(callback: (code: number) => void): () => void {\n    this.exitListeners.add(callback)\n    return () => this.exitListeners.delete(callback)\n  }\n\n  onError(callback: (error: Error) => void): () => void {\n    this.errorListeners.add(callback)\n    return () => this.errorListeners.delete(callback)\n  }\n\n  onOutput(callback: (output: string) => void): () => void {\n    this.outputListeners.add(callback)\n    return () => this.outputListeners.delete(callback)\n  }\n\n  /**\n   * Set error and notify listeners\n   */\n  setError(error: Error): void {\n    this.error = error\n    this.setStatus(\"error\")\n    this.app.lifecycle?.onError?.(error)\n    this.errorListeners.forEach((listener) => listener(error))\n  }\n\n  /**\n   * Emit output\n   */\n  emitOutput(output: string): void {\n    this.outputListeners.forEach((listener) => listener(output))\n  }\n}\n\n/**\n * CLI Plugin Host Implementation\n */\nclass CLIPluginHostImpl implements CLIPluginHost {\n  private options: Required<CLIPluginHostOptions>\n  private appRegistry = createCLIAppRegistry()\n  private adapterRegistry = createCLIAdapterRegistry()\n  private runningInstances = new Map<string, CLIAppInstanceImpl>()\n  private foregroundInstanceId: string | null = null\n  private runtimeContext: OpenTUIRuntimeContext | null = null\n  private _initialized = false\n\n  // Event listeners\n  private launchListeners = new Set<(instance: CLIAppInstance) => void>()\n  private terminateListeners = new Set<(instance: CLIAppInstance, code: number) => void>()\n  private errorListeners = new Set<(instance: CLIAppInstance, error: Error) => void>()\n\n  constructor(options: CLIPluginHostOptions = {}) {\n    this.options = {\n      maxConcurrentApps: options.maxConcurrentApps ?? 10,\n      sandboxMode: options.sandboxMode ?? false,\n      defaultLibrary: options.defaultLibrary ?? \"ink\",\n      defaultLibraryVersion: options.defaultLibraryVersion ?? \">=6.6.0\",\n      adapters: options.adapters ?? [],\n      autoInitialize: options.autoInitialize ?? false,\n    }\n  }\n\n  // ============================================\n  // App Management\n  // ============================================\n\n  registerApp(app: CLIAppDefinition): void {\n    this.appRegistry.register(app)\n  }\n\n  unregisterApp(name: string): void {\n    // Terminate any running instances of this app\n    for (const instance of this.runningInstances.values()) {\n      if (instance.app.manifest.name === name) {\n        instance.terminate(0)\n      }\n    }\n    this.appRegistry.unregister(name)\n  }\n\n  getApp(name: string): CLIAppDefinition | undefined {\n    return this.appRegistry.get(name)\n  }\n\n  listApps(): CLIAppDefinition[] {\n    return this.appRegistry.list()\n  }\n\n  // ============================================\n  // App Execution\n  // ============================================\n\n  async launch(\n    name: string,\n    args: string[] = [],\n    flags: Record<string, string | boolean | number> = {}\n  ): Promise<CLIAppInstance> {\n    if (!this._initialized || !this.runtimeContext) {\n      throw new Error(\"CLI Plugin Host is not initialized\")\n    }\n\n    // Check concurrent app limit\n    if (this.runningInstances.size >= this.options.maxConcurrentApps) {\n      throw new Error(`Maximum concurrent apps (${this.options.maxConcurrentApps}) reached`)\n    }\n\n    // Get app definition\n    const app = this.appRegistry.get(name)\n    if (!app) {\n      throw new Error(`App \"${name}\" not found`)\n    }\n\n    // Get adapter for the app's library\n    const adapter = this.adapterRegistry.getAdapter(app.manifest.library)\n    if (!adapter) {\n      throw new Error(`No adapter registered for library: ${app.manifest.library}`)\n    }\n\n    // Check version compatibility\n    const compatibility = adapter.checkCompatibility(app.manifest.libraryVersion)\n    if (!compatibility.compatible) {\n      const warnings = compatibility.warnings?.join(\"; \") || \"Version mismatch\"\n      throw new Error(`Incompatible version: ${warnings}`)\n    }\n\n    // Create terminal bridge\n    const bridge = createExtendedCLITerminalBridge(this.runtimeContext)\n\n    // Create instance ID\n    const instanceId = generateId()\n\n    // Create app context\n    const context: CLIAppContext = {\n      terminal: bridge,\n      runtime: this.runtimeContext,\n      exit: (code = 0) => {\n        const instance = this.runningInstances.get(instanceId)\n        instance?.terminate(code)\n      },\n      args,\n      flags,\n      instanceId,\n      manifest: app.manifest,\n      suspend: () => {\n        const instance = this.runningInstances.get(instanceId)\n        instance?.suspend()\n      },\n      isForeground: () => this.foregroundInstanceId === instanceId,\n    }\n\n    // Call lifecycle hook\n    if (app.lifecycle?.onBeforeStart) {\n      await app.lifecycle.onBeforeStart(context)\n    }\n\n    // Create render instance\n    const props = { ...context }\n    if (adapter.transformProps) {\n      Object.assign(props, adapter.transformProps(props, app.manifest.libraryVersion))\n    }\n\n    const renderInstance = adapter.createRenderInstance(\n      app.Component as React.ComponentType<unknown>,\n      props,\n      bridge\n    )\n\n    // Create app instance\n    const instance = new CLIAppInstanceImpl(instanceId, app, renderInstance, bridge)\n    this.runningInstances.set(instanceId, instance)\n\n    // Set as foreground if no other foreground\n    if (!this.foregroundInstanceId) {\n      this.foregroundInstanceId = instanceId\n    }\n\n    // Subscribe to exit\n    instance.onExit((code) => {\n      this.runningInstances.delete(instanceId)\n      if (this.foregroundInstanceId === instanceId) {\n        this.foregroundInstanceId = null\n      }\n      this.terminateListeners.forEach((listener) => listener(instance, code))\n    })\n\n    // Subscribe to error\n    instance.onError((error) => {\n      this.errorListeners.forEach((listener) => listener(instance, error))\n    })\n\n    // Notify launch listeners\n    this.launchListeners.forEach((listener) => listener(instance))\n\n    return instance\n  }\n\n  getInstance(instanceId: string): CLIAppInstance | undefined {\n    return this.runningInstances.get(instanceId)\n  }\n\n  listRunningInstances(): CLIAppInstance[] {\n    return Array.from(this.runningInstances.values())\n  }\n\n  terminate(instanceId: string, code: number = 0): void {\n    const instance = this.runningInstances.get(instanceId)\n    instance?.terminate(code)\n  }\n\n  terminateAll(): void {\n    for (const instance of this.runningInstances.values()) {\n      instance.terminate(0)\n    }\n  }\n\n  getForegroundInstance(): CLIAppInstance | undefined {\n    if (!this.foregroundInstanceId) return undefined\n    return this.runningInstances.get(this.foregroundInstanceId)\n  }\n\n  bringToForeground(instanceId: string): void {\n    const instance = this.runningInstances.get(instanceId)\n    if (!instance) return\n\n    // Suspend current foreground\n    if (this.foregroundInstanceId && this.foregroundInstanceId !== instanceId) {\n      const current = this.runningInstances.get(this.foregroundInstanceId)\n      current?.suspend()\n    }\n\n    // Resume and set as foreground\n    instance.resume()\n    this.foregroundInstanceId = instanceId\n  }\n\n  // ============================================\n  // Adapter Management\n  // ============================================\n\n  registerAdapter(adapter: ICLIAdapter): void {\n    this.adapterRegistry.register(adapter)\n  }\n\n  getAdapter(library: CLILibrary): ICLIAdapter | undefined {\n    return this.adapterRegistry.getAdapter(library)\n  }\n\n  supportsLibrary(library: CLILibrary): boolean {\n    return this.adapterRegistry.supportsLibrary(library)\n  }\n\n  listSupportedLibraries(): CLILibrary[] {\n    return this.adapterRegistry.list().map((adapter) => adapter.library)\n  }\n\n  // ============================================\n  // Lifecycle\n  // ============================================\n\n  async initialize(context: OpenTUIRuntimeContext): Promise<void> {\n    if (this._initialized) return\n\n    this.runtimeContext = context\n\n    // Register default adapters\n    const inkAdapter = createInkAdapter()\n    await inkAdapter.initialize()\n    this.adapterRegistry.register(inkAdapter)\n\n    // Register custom adapters from options\n    for (const adapter of this.options.adapters) {\n      await adapter.initialize()\n      this.adapterRegistry.register(adapter)\n    }\n\n    this._initialized = true\n  }\n\n  isInitialized(): boolean {\n    return this._initialized\n  }\n\n  async destroy(): Promise<void> {\n    if (!this._initialized) return\n\n    // Terminate all running apps\n    this.terminateAll()\n\n    // Destroy all adapters\n    for (const adapter of this.adapterRegistry.list()) {\n      await adapter.destroy()\n    }\n\n    this._initialized = false\n    this.runtimeContext = null\n  }\n\n  // ============================================\n  // Events\n  // ============================================\n\n  onAppLaunched(callback: (instance: CLIAppInstance) => void): () => void {\n    this.launchListeners.add(callback)\n    return () => this.launchListeners.delete(callback)\n  }\n\n  onAppTerminated(callback: (instance: CLIAppInstance, code: number) => void): () => void {\n    this.terminateListeners.add(callback)\n    return () => this.terminateListeners.delete(callback)\n  }\n\n  onAppError(callback: (instance: CLIAppInstance, error: Error) => void): () => void {\n    this.errorListeners.add(callback)\n    return () => this.errorListeners.delete(callback)\n  }\n}\n\n/**\n * Create a new CLI Plugin Host\n */\nexport function createCLIPluginHost(options?: CLIPluginHostOptions): CLIPluginHost {\n  return new CLIPluginHostImpl(options)\n}\n\n// Export implementation for advanced use\nexport { CLIPluginHostImpl, CLIAppInstanceImpl }\n",
          "type": "registry:ui"
        }
      ]
    },
    {
      "name": "cli-app-builder",
      "type": "registry:lib",
      "title": "CLI App Builder",
      "description": "Fluent API for creating CLI applications with type-safe configuration.",
      "dependencies": [],
      "registryDependencies": [
        "cli-plugin-types"
      ],
      "files": []
    },
    {
      "name": "cli-plugin",
      "type": "registry:lib",
      "title": "CLI Plugin Framework",
      "description": "Complete CLI plugin framework for OpenTUI. Supports Ink v6.6.0+ and Pastel v4.0.0+ with version negotiation, app registry, and fluent builder API.",
      "dependencies": [
        "ink@^6.6.0"
      ],
      "registryDependencies": [
        "cli-plugin-types",
        "cli-terminal-bridge",
        "cli-adapters",
        "cli-app-registry",
        "cli-plugin-host",
        "cli-app-builder"
      ],
      "files": []
    }
  ]
}